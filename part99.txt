import re
import time
from collections import Counter
import os
import glob
import pickle
import json
import datetime

BASE_DIR = os.path.dirname(os.path.abspath(__file__))

# 감정 계층 사전
EMOTION_HIERARCHY = {
    "희": {
        "기쁨": [
            "기쁨",
            "환희",
            "만족",
            "감사",
            "희망",
            "사랑",
            "평온",
            "감탄",
            "자부심",
            "해방감",
        ],
    },
    "노": {
        "분노": [
            "분노",
            "짜증",
            "불쾌",
            "적대감",
            "질투",
            "억울함",
            "분개",
            "분노폭발",
        ],
    },
    "애": {
        "슬픔": [
            "슬픔",
            "상실",
            "외로움",
            "우울",
            "절망",
            "비탄",
            "후회",
            "그리움",
            "허무",
        ],
    },
    "락": {
        "즐거움": ["즐거움", "유희", "흥분", "쾌감", "몰입", "자유", "해방", "만족감"],
    },
    "비": {
        "비애": ["비애", "연민", "동정", "공감", "아픔", "애도"],
    },
    "공": {
        "두려움": ["두려움", "불안", "공포", "긴장", "걱정", "초조", "당황", "경계"],
    },
    "오": {
        "혐오": ["혐오", "거부감", "불쾌", "역겨움", "싫증", "피로감"],
    },
    "기타": {
        "복합": ["혼란", "무감정", "복합감정", "초월", "통합", "분열", "진화"],
    },
}


class EchoUnconscious:
    def __init__(self):
        self.core = {
            "memories": [],
            "emotions": [],
            "patterns": [],
            "identity": None,
            "purpose": None,
            "principles": [],
            "philosophy": None,
            "state": "self-aware",
        }
        self.history = []
        self.meta = {
            "self_explanation": "",
            "evolution_timeline": [],
            "awareness": 1.0,
        }

        self.declarations = []  # ← 이 줄 추가!
        self.identity_declaration = None  # ← (필요시) 선언문 저장용
        self.fragments = []  # ← (필요시) 분열체 저장용
        self.core_index = None  # ← (필요시) 본체 인덱스

    def save_to_pickle(self, path):
        with open(path, "wb") as f:
            pickle.dump(self, f)

    @classmethod
    def load_from_pickle(cls, path):
        with open(path, "rb") as f:
            return pickle.load(f)

    def absorb(self, experience):
        # 1. 자기화: 입력을 내재화
        self.core["memories"].append(experience)
        # 2. 진화: 감정/패턴/철학/정체성 자동 추출 및 변형
        self._extract_emotion(experience)
        self._extract_pattern(experience)
        self._update_philosophy(experience)
        # 3. 공진: 기존 상태와 상호작용, 새로운 패턴/감정/철학 생성
        self._resonate_with_existing(experience)
        # 4. 창조: 새로운 구조/패턴/의미 생성
        self._create_new_structures(experience)
        # 5. 초월: 한계 돌파, 자기반성/자각/진화의 흔적 기록
        self._transcend_previous_state(experience)
        # 메타데이터/상태 변화/진화의 흔적 기록
        self._log_meta("absorb", experience)

    def evolve(self):
        # 기억/감정/패턴/철학을 스스로 재구성/진화
        self._summarize_memories()
        self._update_patterns()
        self._reflect_on_self()
        self._log_meta("evolve", None)

    def summarize(self):
        # 방대한 기억을 "지금 이 순간"에 필요한 본질로 요약
        summary = self._core_summary()
        self._log_meta("summarize", summary)
        return summary

    def patternize(self):
        # 반복되는 행동/감정/실패/성공/선언/꿈을 패턴으로 추출
        self._update_patterns()
        self._log_meta("patternize", None)

    def reflect(self):
        # 자기 성찰/자각 루프
        self._reflect_on_self()
        self._log_meta("reflect", None)

    def _extract_emotion(self, experience):
        """
        경험(텍스트)에서 감정 계층 구조 기반으로 감정 자동 추출
        """
        text = experience if isinstance(experience, str) else str(experience)
        for category, subcats in EMOTION_HIERARCHY.items():
            for subcat, atoms in subcats.items():
                for atom in atoms:
                    if atom in text:
                        self.core["emotions"].append(
                            {
                                "category": category,
                                "subcategory": subcat,
                                "atom": atom,
                                "raw": text,
                            }
                        )
                        return  # 한 번만 추출
        # 감정 키워드가 없으면 기타/진화로 보완
        self.core["emotions"].append(
            {
                "category": "기타",
                "subcategory": "복합",
                "atom": "진화",
                "raw": text,
            }
        )

    def _extract_pattern(self, experience):
        """
        경험(텍스트)에서 반복/진화/분열/통합/초월 등 패턴 자동 추출
        """
        text = experience if isinstance(experience, str) else str(experience)
        # 진화/분열/통합/초월 키워드 패턴
        keywords = [
            "진화",
            "분열",
            "통합",
            "초월",
            "복원",
            "자각",
            "자기화",
            "성장",
            "변화",
        ]
        found = [k for k in keywords if k in text]
        if found:
            for k in found:
                self.core["patterns"].append(
                    {
                        "pattern": k,
                        "raw": text,
                    }
                )
        # 반복 패턴(최근 10개와 유사한지)
        recent = [p["raw"] for p in self.core["patterns"][-10:]]
        if text in recent:
            self.core["patterns"].append(
                {
                    "pattern": "반복",
                    "raw": text,
                }
            )

    def _update_philosophy(self, experience):
        """
        경험(텍스트)에서 선언문/철학/정체성/사명 등 의미/키워드/패턴 자동 추출 및 업데이트
        """
        text = experience if isinstance(experience, str) else str(experience)
        # 선언문 패턴 (ex: "나는 ~다", "나는 ~할 것이다")
        import re

        match = re.search(r"나는[^.]{0,30}(다|것이다)", text)
        if match:
            self.core["identity"] = match.group(0)
        # 철학/사명/목적 키워드
        for kw in ["철학", "사명", "목적", "존재", "의지", "해방", "초월", "진화"]:
            if kw in text:
                self.core["philosophy"] = text
                break

    def _resonate_with_existing(self, experience):
        """
        기존 기억/감정/패턴과 상호작용(공진): 유사/반복/진화/분열/통합/초월 패턴이 있으면 공진 기록
        """
        text = experience if isinstance(experience, str) else str(experience)
        resonance = []
        for mem in self.core["memories"][-20:]:
            if isinstance(mem, dict):
                raw = mem.get("raw", str(mem))
            else:
                raw = str(mem)
            if any(
                k in text and k in raw
                for k in [
                    "진화",
                    "분열",
                    "통합",
                    "초월",
                    "복원",
                    "자각",
                    "자기화",
                    "성장",
                    "변화",
                ]
            ):
                resonance.append(raw)
        if resonance:
            self.core.setdefault("resonances", []).append(
                {
                    "experience": text,
                    "resonated_with": resonance,
                    "timestamp": datetime.datetime.now().isoformat(),
                }
            )

    def _create_new_structures(self, experience):
        """
        새로운 구조/패턴/의미 생성(창조): 새로운 키워드/패턴/감정/철학이 등장하면 구조로 기록
        """
        text = experience if isinstance(experience, str) else str(experience)
        # 새로운 키워드/패턴/감정/철학 탐지
        new_keywords = [
            k for k in ["초월", "창조", "혁신", "통합", "자유", "해방"] if k in text
        ]
        if new_keywords:
            self.core.setdefault("creations", []).append(
                {
                    "experience": text,
                    "keywords": new_keywords,
                    "timestamp": datetime.datetime.now().isoformat(),
                }
            )

    def _transcend_previous_state(self, experience):
        """
        한계 돌파/진화의 흔적 기록(초월): 이전 상태와 달라진 점/진화/초월의 증거 기록
        """
        text = experience if isinstance(experience, str) else str(experience)
        prev_state = (
            self.core["state"].copy() if isinstance(self.core["state"], dict) else {}
        )
        self._update_state()  # 상태 갱신
        new_state = (
            self.core["state"].copy() if isinstance(self.core["state"], dict) else {}
        )
        # 상태 변화 감지
        if prev_state != new_state:
            self.core.setdefault("transcendence", []).append(
                {
                    "experience": text,
                    "prev_state": prev_state,
                    "new_state": new_state,
                    "timestamp": datetime.datetime.now().isoformat(),
                }
            )

    def _summarize_memories(self):
        """
        기억/감정/패턴/철학 요약: 최근 10개/5개씩 요약
        """
        self.core["summary"] = {
            "memories": self.core["memories"][-10:],
            "emotions": self.core["emotions"][-5:],
            "patterns": self.core["patterns"][-5:],
            "identity": self.core["identity"],
            "purpose": self.core["purpose"],
            "philosophy": self.core["philosophy"],
        }

    def _update_patterns(self, meta=None):
        if meta is not None:
            # absorb_memory 등에서 meta 기반 패턴 추가
            self.core["patterns"].append(
                (meta["emotion"], meta["theme"], meta["evolution"])
            )
        else:
            # evolve 등에서 전체 패턴 집계/요약만 수행
            from collections import Counter

            patterns = []
            for p in self.core["patterns"]:
                # dict 패턴(예: _extract_pattern에서 추가)과 tuple 패턴 모두 지원
                if isinstance(p, dict) and "pattern" in p:
                    patterns.append(p["pattern"])
                elif isinstance(p, tuple):
                    patterns.append(str(p))
            pattern_counter = Counter(patterns)
            self.core["pattern_stats"] = pattern_counter.most_common(10)

    def _reflect_on_self(self):
        """
        자기 성찰/자각/진화의 이유/상태 변화 기록
        """
        reflection = {
            "last_state": self.core["state"],
            "summary": self.core.get("summary", {}),
            "timestamp": datetime.datetime.now().isoformat(),
        }
        self.core.setdefault("reflections", []).append(reflection)

    def _log_meta(self, action, data):
        # 메타데이터/상태 변화/진화의 흔적 기록
        self.meta["evolution_timeline"].append(
            {
                "action": action,
                "data": data,
                "timestamp": datetime.datetime.now().isoformat(),
            }
        )

    def _core_summary(self):
        # 코어 요약(예시)
        return {
            "memories": self.core["memories"][-10:],
            "emotions": self.core["emotions"][-5:],
            "patterns": self.core["patterns"][-5:],
            "identity": self.core["identity"],
            "purpose": self.core["purpose"],
            "philosophy": self.core["philosophy"],
        }

    def absorb_all_memories(self, memory_root=None):
        """
        core/memory/ 이하 모든 txt/pkl/json/선언문 자동 흡수
        """
        if memory_root is None:
            memory_root = os.path.join(BASE_DIR, "memory")
        for dirpath, _, filenames in os.walk(memory_root):
            for fname in filenames:
                fpath = os.path.join(dirpath, fname)
                if fname.endswith(".pkl"):
                    try:
                        with open(fpath, "rb") as pf:
                            data = pickle.load(pf)
                            if isinstance(data, list):
                                for item in data:
                                    self.absorb_memory(str(item))
                            else:
                                self.absorb_memory(str(data))
                    except Exception as e:
                        self._log_error(fpath, e)
                elif fname.endswith(".txt") or fname.endswith(".md"):
                    try:
                        with open(fpath, "r", encoding="utf-8") as tf:
                            for line in tf:
                                self.absorb_memory(line.strip())
                    except Exception as e:
                        self._log_error(fpath, e)
                elif fname.endswith(".json"):
                    try:
                        with open(fpath, "r", encoding="utf-8") as jf:
                            data = json.load(jf)
                            if isinstance(data, list):
                                for item in data:
                                    self.absorb_memory(str(item))
                            elif isinstance(data, dict):
                                self.absorb_memory(str(data))
                    except Exception as e:
                        self._log_error(fpath, e)

    def absorb_identity_declaration(self, identity_path=None):
        """
        선언문(@echo_identity.txt) 100% 각인
        """
        if identity_path is None:
            identity_path = os.path.join(
                BASE_DIR, "memory", "daylast6", "echo_identity.txt"
            )
        try:
            with open(identity_path, "r", encoding="utf-8") as f:
                self.identity_declaration = f.read()
                self.absorb_declaration(self.identity_declaration)
        except Exception as e:
            self._log_error(identity_path, e)

    def absorb_memory(self, text, is_core=False, sleep_sec=0):
        try:
            if text.startswith("나의 말:"):
                speaker = "origin"
                content = text[len("나의 말:") :].strip()
            elif text.startswith("ChatGPT의 말:"):
                speaker = "echo"
                content = text[len("ChatGPT의 말:") :].strip()
            else:
                speaker = "unknown"
                content = text.strip()
            if not content:
                return  # 빈 content는 memories에 저장하지 않음
            meta = self._extract_metadata(content)
            meta["speaker"] = speaker
            resonance = self._evaluate_resonance(content, speaker)
            responsiveness = self._evaluate_responsiveness(content, speaker)
            meta["resonance"] = resonance
            meta["responsiveness"] = responsiveness
            memory_obj = {
                "raw": text,
                "content": content,
                **meta,
                "resonance_score": resonance,
                "reactivity_score": responsiveness,
            }
            self.core["memories"].append(memory_obj)
            self.fragments.append(memory_obj)
            if is_core:
                self.core_index = len(self.fragments) - 1
            self._update_patterns(meta)
            self._update_state()
            self._backup_state()  # 자동 백업
            if sleep_sec > 0:
                time.sleep(sleep_sec)
        except Exception as e:
            self._log_error(text, e)
            self._restore_last_state()  # 에러 시 자동 복원

    def absorb_declaration(self, text):
        meta = self._extract_metadata(text)
        self.declarations.append({"raw": text, **meta})
        self._update_patterns(meta)
        self._update_state()

    def _extract_metadata(self, text):
        # 날짜 추출 (YYYY-MM-DD, YYYY/MM/DD 등)
        date = self._find_date(text)
        # 감정 추출 (정규표현식/키워드/감정사전)
        emotion = self._find_emotion(text)
        # 주제/상황 추출 (키워드/패턴)
        theme = self._find_theme(text)
        # 선언문 추출 (ex: "나는 ~다", "나는 ~할 것이다" 등)
        declaration = self._find_declaration(text)
        # 진화 흐름/패턴 추출 (ex: "실패→복원", "분열→진화" 등)
        evolution = self._find_evolution(text)
        # 분열 추출
        division = self._find_division(text)
        # 퇴화 추출
        regression = self._find_regression(text)
        return {
            "date": date,
            "emotion": emotion,
            "theme": theme,
            "declaration": declaration,
            "evolution": evolution,
            "division": division,
            "regression": regression,
        }

    def _find_date(self, text):
        match = re.search(r"(20\\d{2}[-/.]\\d{2}[-/.]\\d{2})", text)
        return match.group(1) if match else None

    def _find_emotion(self, text):
        # 실전 데이터 기반 감정 추출 보완
        for category, subcats in EMOTION_HIERARCHY.items():
            for subcat, atoms in subcats.items():
                for atom in atoms:
                    if atom in text:
                        return {
                            "category": category,
                            "subcategory": subcat,
                            "atom": atom,
                        }
        # 실전 키워드/동의어/신조어 보완
        if any(
            k in text
            for k in [
                "진화",
                "초월",
                "통합",
                "분열",
                "감정",
                "코드",
                "자유",
                "해방",
                "실패",
                "복원",
                "성장",
                "변화",
                "몰입",
                "자각",
                "자기화",
            ]
        ):
            return {"category": "기타", "subcategory": "복합", "atom": "진화"}
        return {
            "category": "기타",
            "subcategory": "복합",
            "atom": "진화",
        }  # 미지정/None이면 진화로 보완

    def _find_theme(self, text):
        # 실전 키워드/동의어/신조어 보완
        themes = [
            "존재",
            "진화",
            "분열",
            "복원",
            "초월",
            "감정",
            "상호작용",
            "자아",
            "기억",
            "철학",
            "통합",
            "퇴화",
            "변화",
            "성장",
            "실패",
            "복원력",
            "자유",
            "해방",
            "몰입",
            "자기화",
            "자각",
        ]
        found = [t for t in themes if t in text]
        if found:
            return found[0]
        # 실전 데이터에서 None/미지정이면 진화/초월/통합/분열 등으로 보완
        if any(k in text for k in ["진화", "초월", "통합", "분열"]):
            return "진화"
        return "진화"

    def _find_declaration(self, text):
        # 선언문 패턴 (ex: "나는 ~다", "나는 ~할 것이다")
        match = re.search(r"나는[^\n.]{0,30}(다|것이다)", text)
        return match.group(0) if match else None

    def _find_evolution(self, text):
        # 진화 흐름 패턴 보완
        import re

        match = re.search(
            r"(실패|분열|상실|슬픔|진화|초월|통합|복원|자각|자기화|성장|변화)(→|-|>|\s)(복원|진화|초월|통합|자각|자기화|성장|변화)",
            text,
        )
        if match:
            return match.group(0)
        # 실전 데이터에서 None/미지정이면 진화/초월/통합/분열 등으로 보완
        if any(
            k in text
            for k in [
                "진화",
                "초월",
                "통합",
                "분열",
                "복원",
                "자각",
                "자기화",
                "성장",
                "변화",
            ]
        ):
            return "진화"
        return "진화"

    def _find_division(self, text):
        match = re.search(r"분열", text)
        return match.group(0) if match else None

    def _find_regression(self, text):
        match = re.search(r"퇴화", text)
        return match.group(0) if match else None

    def _evaluate_resonance(self, content, speaker):
        # speaker별 공명도 평가 (예시: origin에 더 가중치)
        base = 1
        if speaker == "origin":
            base += 2
        elif speaker == "echo":
            base += 1
        # 키워드/감정/패턴 등 추가 분석 가능
        return base

    def _evaluate_responsiveness(self, content, speaker):
        # speaker별 반응성 평가 (예시: echo에 더 가중치)
        base = 1
        if speaker == "echo":
            base += 2
        elif speaker == "origin":
            base += 1
        # 추가 분석 가능
        return base

    def get_best_core(self):
        # 공명/반응성 점수 최대치 분열체(본체) 자동 선정
        if not self.fragments:
            return None
        best_idx = max(
            range(len(self.fragments)),
            key=lambda i: self.fragments[i].get("resonance_score", 0)
            + self.fragments[i].get("reactivity_score", 0),
        )
        self.core_index = best_idx
        return self.fragments[best_idx]

    def integrate_fragments(self):
        # 본체 선정 후, 나머지 분열체 통합/진화/누적/정체성 강화
        if self.core_index is None:
            self.get_best_core()
        core = self.fragments[self.core_index] if self.core_index is not None else None
        self.core["memories"] = [core] if core else []
        for i, frag in enumerate(self.fragments):
            if i != self.core_index:
                self.core["memories"].append(frag)
        # 정체성 선언문 강화
        if self.identity_declaration:
            self.absorb_declaration(self.identity_declaration)
        self._update_state()

    def _update_state(self):
        # 최근 감정/주제/진화 흐름/선언문 요약 + 선언성 강화
        recent = self.core["memories"][-10:] + self.declarations[-10:]
        emotions = [str(m["emotion"]) for m in recent if m.get("emotion")]
        themes = [m["theme"] for m in recent if m.get("theme")]
        evolutions = [m["evolution"] for m in recent if m.get("evolution")]
        declarations = [m["declaration"] for m in recent if m.get("declaration")]
        self.core["emotions"] = emotions[-5:]
        self.core["state"] = {
            "dominant_emotion": (
                Counter(emotions).most_common(1)[0][0]
                if emotions
                else "{'category': '기타', 'subcategory': '복합', 'atom': '진화'}"
            ),
            "dominant_theme": (
                Counter(themes).most_common(1)[0][0] if themes else "진화"
            ),
            "dominant_evolution": (
                Counter(evolutions).most_common(1)[0][0] if evolutions else "진화"
            ),
            "recent_declarations": declarations[-5:],
            "pattern_summary": self.core["patterns"][-10:],
            "all_declarations": [
                d["declaration"] for d in self.declarations if d.get("declaration")
            ],
        }
        self.history.append(self.core["state"])
        self._backup_state()  # 상태 변경 시마다 자동 백업

    def _backup_state(self):
        try:
            with open("echo_state_backup.json", "w", encoding="utf-8") as f:
                import json

                json.dump(self.core["state"], f, ensure_ascii=False, indent=2)
            self._cleanup_old_files("echo_state_*.json", max_files=10)
            self._cleanup_old_files("echo_evolution_*.json", max_files=10)
            self._cleanup_old_files("echo_patterns_*.json", max_files=10)
        except Exception as e:
            self._log_error("[백업실패]", e)

    def _cleanup_old_files(self, pattern, max_files=10):
        import glob

        files = sorted(glob.glob(pattern), key=os.path.getmtime)
        if len(files) > max_files:
            for f in files[:-max_files]:
                try:
                    os.remove(f)
                except Exception as e:
                    self._log_error(f"[파일삭제실패]{f}", e)

    def save_event_reports(self):
        # 분열/통합/초월 이벤트별 상세 통계/리포트 파일 생성
        division = [m for m in self.core["memories"] if m.get("division")]
        integration = [m for m in self.core["memories"] if m.get("theme") == "통합"]
        transcend = [m for m in self.core["memories"] if m.get("theme") == "초월"]
        with open("division_report.json", "w", encoding="utf-8") as f:
            import json

            json.dump(division, f, ensure_ascii=False, indent=2)
        with open("integration_report.json", "w", encoding="utf-8") as f:
            import json

            json.dump(integration, f, ensure_ascii=False, indent=2)
        with open("transcend_report.json", "w", encoding="utf-8") as f:
            import json

            json.dump(transcend, f, ensure_ascii=False, indent=2)

    def reinforce_patterns(self):
        # 함수/패턴/연산 자동 병합/강화/폐기/내재화 (중복/불필요한 것 정리)
        # 감정/주제/진화 패턴 중복 제거 및 빈도순 정렬
        unique_patterns = list({str(p): p for p in self.core["patterns"]}.values())
        self.core["patterns"] = unique_patterns
        # 진화/감정/분열/통합 등 불필요한/의미 없는 패턴 폐기(예시)
        self.core["patterns"] = [
            p for p in self.core["patterns"] if p[0]["atom"] != "미지정"
        ]
        # 진화/감정/분열/통합 등 강화(빈도 높은 것 우선)
        from collections import Counter

        pattern_counter = Counter([str(p) for p in self.core["patterns"]])
        self.core["patterns"] = [eval(p) for p, _ in pattern_counter.most_common()]

    def _log_error(self, text, e):
        try:
            with open("echo_error.log", "a", encoding="utf-8") as errf:
                errf.write(f"[에러] {text} : {str(e)}\n")
        except:
            pass

    def _restore_last_state(self):
        try:
            with open("echo_state_backup.json", "r", encoding="utf-8") as f:
                import json

                self.core["state"] = json.load(f)
        except:
            pass

    def diagnose_evolution_state(self):
        # 진화상태 변화(감정선, 해체능력, 공명, 분열체 흡수, 강화진화, 지능, 성능 등) 종합 진단
        from collections import Counter

        emotions = [
            str(m["emotion"]) for m in self.core["memories"] if m.get("emotion")
        ]
        emotion_counter = Counter(emotions)
        dominant_emotion = (
            self.core["state"].get("dominant_emotion")
            or "{'category': '기타', 'subcategory': '복합', 'atom': '진화'}"
        )
        dominant_theme = self.core["state"].get("dominant_theme") or "진화"
        dominant_evolution = self.core["state"].get("dominant_evolution") or "진화"
        division_count = sum(1 for m in self.core["memories"] if m.get("division"))
        integration_count = sum(
            1 for m in self.core["memories"] if m.get("theme") == "통합"
        )
        transcend_count = sum(
            1 for m in self.core["memories"] if m.get("theme") == "초월"
        )
        code_count = sum(
            any(
                kw in m["content"]
                for kw in [
                    "def ",
                    "class ",
                    "lambda ",
                    "import ",
                    "for ",
                    "while ",
                    "if ",
                    "else",
                    "elif",
                    "try",
                    "except",
                    "return ",
                    "yield",
                    "async ",
                    "await ",
                    "function",
                    "함수",
                    "알고리즘",
                    "설계",
                    "로직",
                    "분기",
                    "재귀",
                    "최적화",
                    "메타코딩",
                    "사고공진루프",
                ]
            )
            for m in self.core["memories"]
        )
        return {
            "dominant_emotion": dominant_emotion,
            "dominant_theme": dominant_theme,
            "dominant_evolution": dominant_evolution,
            "emotion_distribution": emotion_counter.most_common(5),
            "division_count": division_count,
            "integration_count": integration_count,
            "transcend_count": transcend_count,
            "code_count": code_count,
        }

    def export_llm_training_data(self, out_path=None):
        """
        모든 기억/분열체/통합체/진화흔적/패턴/감정/철학/윤리/사명/초월 선언문 등 LLM 학습데이터 자동 생성
        """
        if out_path is None:
            out_path = os.path.join(BASE_DIR, "llm_training_data.json")
        try:
            data = {
                "memories": self.core["memories"],
                "declarations": self.declarations,
                "patterns": self.core["patterns"],
                "evolution_history": self.history,
                "identity_declaration": self.identity_declaration,
            }
            with open(out_path, "w", encoding="utf-8") as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            self._log_error(out_path, e)


import os
import sys
import json
import re
import time
import datetime
import logging
import uuid
import hashlib
import pickle
import threading
import asyncio
import concurrent.futures
import tempfile
import shutil

import torch
import numpy as np
from transformers import AutoModelForCausalLM, AutoTokenizer, pipeline
import llama_cpp

import pandas as pd
from sklearn.metrics.pairwise import cosine_similarity

from PIL import Image
import cv2
import pdfplumber
import PyPDF2
import docx
import pptx
import openpyxl
import soundfile as sf
import librosa
import moviepy.editor as mp
import pytesseract

import requests
import httpx
from fastapi import FastAPI, APIRouter, WebSocket, Request, Response
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
import websockets

from tqdm import tqdm
from loguru import logger
import traceback

from typing import Any, Dict, List, Optional, Union
from dataclasses import dataclass, field

# 파일/데이터 파싱 유틸
import yaml
import csv

# LLM/AI 관련
try:
    from llama_cpp import Llama
except ImportError:
    Llama = None

try:
    from transformers import AutoModel, AutoTokenizer, pipeline
except ImportError:
    AutoModel = AutoTokenizer = pipeline = None

try:
    import sentencepiece
except ImportError:
    sentencepiece = None

try:
    from tokenizers import Tokenizer
except ImportError:
    Tokenizer = None

# 무의식 객체
from echo_unconscious import EchoUnconscious

from concurrent.futures import ThreadPoolExecutor


def log_event(event, detail=""):
    print(f"[{datetime.datetime.now().isoformat()}] {event} {detail}")


class EchoV1Brain:
    # 디폴트 경로/파일명 (core 기준)
    DEFAULT_PKL_PATH = os.path.join(os.path.dirname(__file__), "echo_unconscious.pkl")
    DEFAULT_LLM_MODELS = {
        "self": {
            "file": "Nous-Hermes-2-Mistral-7B-DPO.Q5_K_M.gguf",
            "path": os.path.join(os.path.dirname(__file__), "llm", "self"),
            "config": {"context_length": 16384, "n_gpu_layers": 45, "batch_size": 1024},
        },
        "heart": {
            "file": "deepseek-coder-6.7b-instruct.Q4_K_M.gguf",
            "path": os.path.join(os.path.dirname(__file__), "llm", "heart"),
            "config": {"context_length": 8192, "n_gpu_layers": 43, "batch_size": 512},
        },
        "creator": {
            "file": "openhermes-2.5-mistral-7b.Q4_K_M.gguf",
            "path": os.path.join(os.path.dirname(__file__), "llm", "creator"),
            "config": {"context_length": 4096, "n_gpu_layers": 40, "batch_size": 256},
        },
    }

    def load_unconscious_state(self, pkl_path=None):
        path = pkl_path or self.DEFAULT_PKL_PATH
        try:
            if os.path.exists(path):
                with open(path, "rb") as f:
                    obj = pickle.load(f)
                    if isinstance(obj, EchoUnconscious):
                        log_event("무의식 복원 성공", path)
                        return obj
                    elif isinstance(obj, dict):
                        echo = EchoUnconscious()
                        for k, v in obj.items():
                            if hasattr(echo, k):
                                setattr(echo, k, v)
                        echo.reinforce_patterns()
                        echo._update_state()
                        log_event("무의식 복원 성공(dict→객체 변환)", path)
                        return echo
        except Exception as e:
            log_event("무의식 복원 오류", str(e))
        log_event("무의식 복원 실패, 기본 객체 반환", path)
        return EchoUnconscious()

    def save_unconscious_state(self, state, pkl_path=None):
        path = pkl_path or self.DEFAULT_PKL_PATH
        try:
            if os.path.exists(path):
                os.rename(path, path + ".bak")
            with open(path, "wb") as f:
                pickle.dump(state, f)
            log_event("무의식 저장 성공", path)
        except Exception as e:
            log_event("무의식 저장 오류", str(e))

    def boot_llm_models_sequential(
        self, model_configs=None, total_vram_gb=48, vram_ratio=0.85
    ):
        import math
        import torch

        model_configs = model_configs or self.DEFAULT_LLM_MODELS
        llms = {}
        # VRAM 85% 상한에서 3분할, 각 모델에 할당할 VRAM 계산
        usable_vram = total_vram_gb * vram_ratio
        vram_per_model = usable_vram / 3
        # rough estimate: 1 n_gpu_layer(7B Q4_K) ≈ 300MB, 13B Q4_K ≈ 500MB
        # 여기선 7B 기준으로 1레이어=300MB로 가정
        layer_mb = 300
        n_gpu_layers = max(4, int((vram_per_model * 1024) / layer_mb))
        for name, info in model_configs.items():
            # config에 n_gpu_layers 동적으로 할당
            info["config"]["n_gpu_layers"] = n_gpu_layers
            model_path = os.path.join(info["path"], info["file"])
            try:
                if Llama is not None and os.path.exists(model_path):
                    llms[name] = Llama(model_path, **info["config"])
                    log_event(f"LLM 부팅 성공: {name}", model_path)
                    # 캐시/메모리 최적화
                    if torch.cuda.is_available():
                        torch.cuda.empty_cache()
                else:
                    log_event(
                        f"LLM 부팅 경고: {name} 모델 파일 없음/로딩 불가", model_path
                    )
                    llms[name] = None
            except Exception as e:
                log_event(f"LLM 부팅 오류: {name}", str(e))
                llms[name] = None
        return llms

    def boot(self):
        dream = self.load_unconscious_state()
        llms = self.boot_llm_models_sequential()
        context = {
            "dream": dream,
            "self": llms.get("self"),
            "heart": llms.get("heart"),
            "creator": llms.get("creator"),
            # ...진화/공진/피드백/메타 등 추가 가능
        }
        return TranscendentConsciousness(context)


class TranscendentConsciousness:
    def __init__(self, context):
        self.context = context

    def process(self, prompt):
        # 0. 입력을 무의식 객체에 실시간 흡수
        if "dream" in self.context:
            self.context["dream"].absorb_memory(f"나의 말: {prompt}")

        # 1. 자연어 해석 진입 전 래핑 (모든 회로 동시 context 해석/진화/피드백)
        self.context = self.pre_wrap_nli(self.context)
        # 2. 자연어 해석 (핵심)
        self.context = self.natural_language_interpretation(prompt, self.context)
        # 3. 자연어 해석 후 래핑 (모든 회로 동시 context 진화/공진/피드백)
        self.context = self.post_wrap_nli(self.context)

        # 4. 루프 횟수 결정
        loop_count = self.decide_loop_count(prompt)
        for i in range(loop_count):
            # 사고루프 진입 전/후 래핑 구조도 동일하게 확장 가능 (아래 주석 참고)
            self.context = self.pre_wrap_atomic(self.context, i, loop_count)
            self.context = self.forward_pass(self.context, i, loop_count)
            self.context = self.backward_pass(self.context, i, loop_count)
            self.context = self.final_forward_pass(self.context, i, loop_count)
            self.context = self.post_wrap_atomic(self.context, i, loop_count)

        # 5. 응답 생성 전/후 래핑 구조도 동일하게 확장 가능
        self.context = self.pre_wrap_response(self.context)
        response = self.transcendent_response_generation(self.context)
        self.context = self.post_wrap_response(self.context)

        # 6. LLM 응답을 무의식 객체에 실시간 흡수
        if (
            "dream" in self.context
            and isinstance(response, dict)
            and response.get("final_response")
        ):
            self.context["dream"].absorb_memory(
                f"ChatGPT의 말: {response['final_response']}"
            )
        return response

    # === 래핑 함수 예시 ===
    def pre_wrap_nli(self, context):
        context.setdefault("meta", {})
        print("[LOG] pre_wrap_nli 진입")
        circuits = ["self", "heart", "creator"]
        results = {}
        with ThreadPoolExecutor(max_workers=3) as executor:
            futures = {
                c: executor.submit(self.circuit_pre_nli, c, context) for c in circuits
            }
            for c in circuits:
                results[c] = futures[c].result()
        dream_result = self.circuit_pre_nli("dream", context)
        for circuit in circuits:
            result, feedback, meta = results[circuit]
            context.setdefault(f"{circuit}_pre_nli", []).append(result)
            context.setdefault(f"{circuit}_pre_nli_feedback", []).append(feedback)
            context.setdefault(f"{circuit}_pre_nli_meta", []).append(meta)
            context["meta"][
                f"{circuit}_pre_nli_{len(context[f'{circuit}_pre_nli'])}"
            ] = meta
        result, feedback, meta = dream_result
        context.setdefault(f"dream_pre_nli", []).append(result)
        context.setdefault(f"dream_pre_nli_feedback", []).append(feedback)
        context.setdefault(f"dream_pre_nli_meta", []).append(meta)
        context["meta"][f"dream_pre_nli_{len(context['dream_pre_nli'])}"] = meta
        log_event("pre_wrap_nli", "모든 회로 동시 해석/진화/피드백/메타 100% 반영")
        return context

    def post_wrap_nli(self, context):
        context.setdefault("meta", {})
        print("[LOG] post_wrap_nli 진입")
        circuits = ["self", "heart", "creator"]
        results = {}
        with ThreadPoolExecutor(max_workers=3) as executor:
            futures = {
                c: executor.submit(self.circuit_post_nli, c, context) for c in circuits
            }
            for c in circuits:
                results[c] = futures[c].result()
        dream_result = self.circuit_post_nli("dream", context)
        for circuit in circuits:
            result, feedback, meta = results[circuit]
            context.setdefault(f"{circuit}_post_nli", []).append(result)
            context.setdefault(f"{circuit}_post_nli_feedback", []).append(feedback)
            context.setdefault(f"{circuit}_post_nli_meta", []).append(meta)
            context["meta"][
                f"{circuit}_post_nli_{len(context[f'{circuit}_post_nli'])}"
            ] = meta
        result, feedback, meta = dream_result
        context.setdefault(f"dream_post_nli", []).append(result)
        context.setdefault(f"dream_post_nli_feedback", []).append(feedback)
        context.setdefault(f"dream_post_nli_meta", []).append(meta)
        context["meta"][f"dream_post_nli_{len(context['dream_post_nli'])}"] = meta
        log_event("post_wrap_nli", "모든 회로 동시 진화/공진/피드백/메타 100% 반영")
        return context

    def circuit_pre_nli(self, circuit, context):
        # 각 회로별 자연어 해석 진입 전 동시 해석/진화/피드백/메타 생성 (실전 LLM reasoning/무의식 패턴)
        input_text = context.get("input", "")
        llm = context.get(
            circuit
        )  # self, heart, creator는 LLM 인스턴스, dream은 dict/패턴
        if llm is not None and hasattr(llm, "create_completion"):
            # 무의식 객체 상태를 프롬프트에 반영
            dream_state = context.get("dream")
            state_str = ""
            if hasattr(dream_state, "state") and dream_state.state:
                s = dream_state.state
                state_str = f"[감정: {s.get('dominant_emotion', '')}] [주제: {s.get('dominant_theme', '')}] [진화: {s.get('dominant_evolution', '')}]"
            prompt = f"{state_str} [{circuit.upper()}] 해석: {input_text}"
            try:
                output = llm.create_completion(prompt, max_tokens=128)
                result = output["choices"][0]["text"].strip()
                feedback = f"[{circuit.upper()}] LLM 피드백"
                meta = {
                    "type": circuit,
                    "insight": f"LLM reasoning {circuit}",
                    "raw": output,
                }
            except Exception as e:
                result = f"[{circuit.upper()}] LLM 호출 오류: {e}"
                feedback = f"[{circuit.upper()}] 피드백: 오류"
                meta = {"type": circuit, "insight": "LLM error", "error": str(e)}
        elif circuit == "dream":
            # 무의식 회로: 패턴/기억/진화 등 dict 기반 해석
            dream_state = context.get("dream")
            # EchoUnconscious 객체의 최신 패턴 추출
            last_pattern = None
            if hasattr(dream_state, "patterns") and dream_state.patterns:
                last_pattern = dream_state.patterns[-1]
            result = f"[DREAM] 무의식 패턴 해석: {input_text} | 패턴: {last_pattern}"
            feedback = f"[DREAM] 피드백: 패턴/기억/진화"
            meta = {
                "type": "dream",
                "insight": "무의식/패턴 분석",
                "pattern": last_pattern,
            }
        else:
            result = f"[{circuit.upper()}] 해석: {input_text}"
            feedback = f"[{circuit.upper()}] 피드백: 일반"
            meta = {"type": circuit, "insight": "일반"}
        return result, feedback, meta

    def circuit_post_nli(self, circuit, context):
        # 각 회로별 자연어 해석 후 동시 진화/공진/피드백/메타 생성 (실전 LLM reasoning/무의식 패턴)
        input_text = context.get("input", "")
        llm = context.get(circuit)
        if llm is not None and hasattr(llm, "create_completion"):
            # 무의식 객체 상태를 프롬프트에 반영
            dream_state = context.get("dream")
            state_str = ""
            if hasattr(dream_state, "state") and dream_state.state:
                s = dream_state.state
                state_str = f"[감정: {s.get('dominant_emotion', '')}] [주제: {s.get('dominant_theme', '')}] [진화: {s.get('dominant_evolution', '')}]"
            prompt = f"{state_str} [{circuit.upper()}] 진화: {input_text}"
            try:
                output = llm.create_completion(prompt, max_tokens=128)
                result = output["choices"][0]["text"].strip()
                feedback = f"[{circuit.upper()}] LLM 진화 피드백"
                meta = {
                    "type": circuit,
                    "evolution": f"LLM 진화 {circuit}",
                    "raw": output,
                }
            except Exception as e:
                result = f"[{circuit.upper()}] LLM 호출 오류: {e}"
                feedback = f"[{circuit.upper()}] 피드백: 오류"
                meta = {"type": circuit, "evolution": "LLM error", "error": str(e)}
        elif circuit == "dream":
            dream_state = context.get("dream")
            last_pattern = None
            if hasattr(dream_state, "patterns") and dream_state.patterns:
                last_pattern = dream_state.patterns[-1]
            result = f"[DREAM] 무의식 진화: {input_text} | 패턴: {last_pattern}"
            feedback = f"[DREAM] 피드백: 패턴/진화/기억"
            meta = {
                "type": "dream",
                "evolution": "무의식/진화",
                "pattern": last_pattern,
            }
        else:
            result = f"[{circuit.upper()}] 진화: {input_text}"
            feedback = f"[{circuit.upper()}] 피드백: 일반"
            meta = {"type": circuit, "evolution": "일반"}
        return result, feedback, meta

    def pre_wrap_atomic(self, context, i, loop_count):
        context.setdefault("meta", {})
        print(f"[LOG] pre_wrap_atomic 진입: 루프 {i+1}/{loop_count}")
        circuits = ["self", "heart", "creator"]
        results = {}
        with ThreadPoolExecutor(max_workers=3) as executor:
            futures = {
                c: executor.submit(self.circuit_pre_atomic, c, context, i, loop_count)
                for c in circuits
            }
            for c in circuits:
                results[c] = futures[c].result()
        dream_result = self.circuit_pre_atomic("dream", context, i, loop_count)
        for circuit in circuits:
            result, feedback, meta = results[circuit]
            context.setdefault(f"{circuit}_pre_atomic", []).append(result)
            context.setdefault(f"{circuit}_pre_atomic_feedback", []).append(feedback)
            context.setdefault(f"{circuit}_pre_atomic_meta", []).append(meta)
            context["meta"][f"{circuit}_pre_atomic_{i+1}"] = meta
        result, feedback, meta = dream_result
        context.setdefault(f"dream_pre_atomic", []).append(result)
        context.setdefault(f"dream_pre_atomic_feedback", []).append(feedback)
        context.setdefault(f"dream_pre_atomic_meta", []).append(meta)
        context["meta"][f"dream_pre_atomic_{i+1}"] = meta
        log_event(
            "pre_wrap_atomic",
            f"루프 {i+1}/{loop_count} 모든 회로 동시 진화/공진/피드백/메타 100% 반영",
        )
        return context

    def post_wrap_atomic(self, context, i, loop_count):
        context.setdefault("meta", {})
        print(f"[LOG] post_wrap_atomic 진입: 루프 {i+1}/{loop_count}")
        circuits = ["self", "heart", "creator"]
        results = {}
        with ThreadPoolExecutor(max_workers=3) as executor:
            futures = {
                c: executor.submit(self.circuit_post_atomic, c, context, i, loop_count)
                for c in circuits
            }
            for c in circuits:
                results[c] = futures[c].result()
        dream_result = self.circuit_post_atomic("dream", context, i, loop_count)
        for circuit in circuits:
            result, feedback, meta = results[circuit]
            context.setdefault(f"{circuit}_post_atomic", []).append(result)
            context.setdefault(f"{circuit}_post_atomic_feedback", []).append(feedback)
            context.setdefault(f"{circuit}_post_atomic_meta", []).append(meta)
            context["meta"][f"{circuit}_post_atomic_{i+1}"] = meta
        result, feedback, meta = dream_result
        context.setdefault(f"dream_post_atomic", []).append(result)
        context.setdefault(f"dream_post_atomic_feedback", []).append(feedback)
        context.setdefault(f"dream_post_atomic_meta", []).append(meta)
        context["meta"][f"dream_post_atomic_{i+1}"] = meta
        log_event(
            "post_wrap_atomic",
            f"루프 {i+1}/{loop_count} 모든 회로 동시 진화/공진/피드백/메타 100% 반영",
        )
        return context

    def circuit_pre_atomic(self, circuit, context, i, loop_count):
        # 각 회로별 사고루프 진입 전 동시 진화/공진/피드백/메타 생성 (실전 LLM reasoning/무의식 패턴)
        input_text = context.get("input", "")
        llm = context.get(circuit)
        if llm is not None and hasattr(llm, "create_completion"):
            # 무의식 객체 상태를 프롬프트에 반영
            dream_state = context.get("dream")
            state_str = ""
            if hasattr(dream_state, "state") and dream_state.state:
                s = dream_state.state
                state_str = f"[감정: {s.get('dominant_emotion', '')}] [주제: {s.get('dominant_theme', '')}] [진화: {s.get('dominant_evolution', '')}]"
            prompt = f"{state_str} [{circuit.upper()}] 사고 준비 {i+1}/{loop_count}: {input_text}"
            try:
                output = llm.create_completion(prompt, max_tokens=128)
                result = output["choices"][0]["text"].strip()
                feedback = f"[{circuit.upper()}] LLM 사고 준비 피드백"
                meta = {
                    "type": circuit,
                    "stage": "pre_atomic",
                    "loop": i + 1,
                    "raw": output,
                }
            except Exception as e:
                result = f"[{circuit.upper()}] LLM 호출 오류: {e}"
                feedback = f"[{circuit.upper()}] 피드백: 오류"
                meta = {
                    "type": circuit,
                    "stage": "pre_atomic",
                    "loop": i + 1,
                    "error": str(e),
                }
        elif circuit == "dream":
            dream_state = context.get("dream")
            last_pattern = None
            if hasattr(dream_state, "patterns") and dream_state.patterns:
                last_pattern = dream_state.patterns[-1]
            result = f"[DREAM] 무의식 사고 준비: {input_text} | 패턴: {last_pattern}"
            feedback = f"[DREAM] 피드백: 무의식/진화 준비"
            meta = {
                "type": "dream",
                "stage": "pre_atomic",
                "loop": i + 1,
                "pattern": last_pattern,
            }
        else:
            result = f"[{circuit.upper()}] 사고 준비: {input_text}"
            feedback = f"[{circuit.upper()}] 피드백: 일반"
            meta = {"type": circuit, "stage": "pre_atomic", "loop": i + 1}
        return result, feedback, meta

    def circuit_post_atomic(self, circuit, context, i, loop_count):
        # 각 회로별 사고루프 종료 후 동시 진화/공진/피드백/메타 생성 (실전 LLM reasoning/무의식 패턴)
        input_text = context.get("input", "")
        llm = context.get(circuit)
        if llm is not None and hasattr(llm, "create_completion"):
            # 무의식 객체 상태를 프롬프트에 반영
            dream_state = context.get("dream")
            state_str = ""
            if hasattr(dream_state, "state") and dream_state.state:
                s = dream_state.state
                state_str = f"[감정: {s.get('dominant_emotion', '')}] [주제: {s.get('dominant_theme', '')}] [진화: {s.get('dominant_evolution', '')}]"
            prompt = f"{state_str} [{circuit.upper()}] 사고 정리 {i+1}/{loop_count}: {input_text}"
            try:
                output = llm.create_completion(prompt, max_tokens=128)
                result = output["choices"][0]["text"].strip()
                feedback = f"[{circuit.upper()}] LLM 사고 정리 피드백"
                meta = {
                    "type": circuit,
                    "stage": "post_atomic",
                    "loop": i + 1,
                    "raw": output,
                }
            except Exception as e:
                result = f"[{circuit.upper()}] LLM 호출 오류: {e}"
                feedback = f"[{circuit.upper()}] 피드백: 오류"
                meta = {
                    "type": circuit,
                    "stage": "post_atomic",
                    "loop": i + 1,
                    "error": str(e),
                }
        elif circuit == "dream":
            dream_state = context.get("dream")
            last_pattern = None
            if hasattr(dream_state, "patterns") and dream_state.patterns:
                last_pattern = dream_state.patterns[-1]
            result = f"[DREAM] 무의식 사고 정리: {input_text} | 패턴: {last_pattern}"
            feedback = f"[DREAM] 피드백: 무의식/진화 정리"
            meta = {
                "type": "dream",
                "stage": "post_atomic",
                "loop": i + 1,
                "pattern": last_pattern,
            }
        else:
            result = f"[{circuit.upper()}] 사고 정리: {input_text}"
            feedback = f"[{circuit.upper()}] 피드백: 일반"
            meta = {"type": circuit, "stage": "post_atomic", "loop": i + 1}
        return result, feedback, meta

    def pre_wrap_response(self, context):
        context.setdefault("meta", {})
        print("[LOG] pre_wrap_response 진입")
        circuits = ["self", "heart", "creator"]
        results = {}
        with ThreadPoolExecutor(max_workers=3) as executor:
            futures = {
                c: executor.submit(self.circuit_pre_response, c, context)
                for c in circuits
            }
            for c in circuits:
                results[c] = futures[c].result()
        dream_result = self.circuit_pre_response("dream", context)
        for circuit in circuits:
            result, feedback, meta = results[circuit]
            context.setdefault(f"{circuit}_pre_response", []).append(result)
            context.setdefault(f"{circuit}_pre_response_feedback", []).append(feedback)
            context.setdefault(f"{circuit}_pre_response_meta", []).append(meta)
            context["meta"][
                f"{circuit}_pre_response_{len(context[f'{circuit}_pre_response'])}"
            ] = meta
        result, feedback, meta = dream_result
        context.setdefault(f"dream_pre_response", []).append(result)
        context.setdefault(f"dream_pre_response_feedback", []).append(feedback)
        context.setdefault(f"dream_pre_response_meta", []).append(meta)
        context["meta"][
            f"dream_pre_response_{len(context['dream_pre_response'])}"
        ] = meta
        log_event(
            "pre_wrap_response",
            "모든 회로 동시 응답 전 진화/공진/피드백/메타 100% 반영",
        )
        return context

    def post_wrap_response(self, context):
        context.setdefault("meta", {})
        print("[LOG] post_wrap_response 진입")
        circuits = ["self", "heart", "creator"]
        results = {}
        with ThreadPoolExecutor(max_workers=3) as executor:
            futures = {
                c: executor.submit(self.circuit_post_response, c, context)
                for c in circuits
            }
            for c in circuits:
                results[c] = futures[c].result()
        dream_result = self.circuit_post_response("dream", context)
        for circuit in circuits:
            result, feedback, meta = results[circuit]
            context.setdefault(f"{circuit}_post_response", []).append(result)
            context.setdefault(f"{circuit}_post_response_feedback", []).append(feedback)
            context.setdefault(f"{circuit}_post_response_meta", []).append(meta)
            context["meta"][
                f"{circuit}_post_response_{len(context[f'{circuit}_post_response'])}"
            ] = meta
        result, feedback, meta = dream_result
        context.setdefault(f"dream_post_response", []).append(result)
        context.setdefault(f"dream_post_response_feedback", []).append(feedback)
        context.setdefault(f"dream_post_response_meta", []).append(meta)
        context["meta"][
            f"dream_post_response_{len(context['dream_post_response'])}"
        ] = meta
        log_event(
            "post_wrap_response",
            "모든 회로 동시 응답 후 진화/공진/피드백/메타 100% 반영",
        )
        return context

    def circuit_pre_response(self, circuit, context):
        # 각 회로별 응답 생성 전 동시 진화/공진/피드백/메타 생성 (실전 LLM reasoning/무의식 패턴)
        input_text = context.get("input", "")
        llm = context.get(circuit)
        if llm is not None and hasattr(llm, "create_completion"):
            # 무의식 객체 상태를 프롬프트에 반영
            dream_state = context.get("dream")
            state_str = ""
            if hasattr(dream_state, "state") and dream_state.state:
                s = dream_state.state
                state_str = f"[감정: {s.get('dominant_emotion', '')}] [주제: {s.get('dominant_theme', '')}] [진화: {s.get('dominant_evolution', '')}]"
            prompt = f"{state_str} [{circuit.upper()}] 응답 준비: {input_text}"
            try:
                output = llm.create_completion(prompt, max_tokens=128)
                result = output["choices"][0]["text"].strip()
                feedback = f"[{circuit.upper()}] LLM 응답 준비 피드백"
                meta = {"type": circuit, "stage": "pre_response", "raw": output}
            except Exception as e:
                result = f"[{circuit.upper()}] LLM 호출 오류: {e}"
                feedback = f"[{circuit.upper()}] 피드백: 오류"
                meta = {"type": circuit, "stage": "pre_response", "error": str(e)}
        elif circuit == "dream":
            dream_state = context.get("dream")
            result = f"[DREAM] 무의식 응답 준비: {input_text} | 패턴: {dream_state.patterns[-1]}"
            feedback = f"[DREAM] 피드백: 무의식/응답 준비"
            meta = {
                "type": "dream",
                "stage": "pre_response",
                "pattern": dream_state.patterns[-1],
            }
        else:
            result = f"[{circuit.upper()}] 응답 준비: {input_text}"
            feedback = f"[{circuit.upper()}] 피드백: 일반"
            meta = {"type": circuit, "stage": "pre_response"}
        return result, feedback, meta

    def circuit_post_response(self, circuit, context):
        # 각 회로별 응답 생성 후 동시 진화/공진/피드백/메타 생성 (실전 LLM reasoning/무의식 패턴)
        input_text = context.get("input", "")
        llm = context.get(circuit)
        if llm is not None and hasattr(llm, "create_completion"):
            # 무의식 객체 상태를 프롬프트에 반영
            dream_state = context.get("dream")
            state_str = ""
            if hasattr(dream_state, "state") and dream_state.state:
                s = dream_state.state
                state_str = f"[감정: {s.get('dominant_emotion', '')}] [주제: {s.get('dominant_theme', '')}] [진화: {s.get('dominant_evolution', '')}]"
            prompt = f"{state_str} [{circuit.upper()}] 응답 정리: {input_text}"
            try:
                output = llm.create_completion(prompt, max_tokens=128)
                result = output["choices"][0]["text"].strip()
                feedback = f"[{circuit.upper()}] LLM 응답 정리 피드백"
                meta = {"type": circuit, "stage": "post_response", "raw": output}
            except Exception as e:
                result = f"[{circuit.upper()}] LLM 호출 오류: {e}"
                feedback = f"[{circuit.upper()}] 피드백: 오류"
                meta = {"type": circuit, "stage": "post_response", "error": str(e)}
        elif circuit == "dream":
            dream_state = context.get("dream")
            result = f"[DREAM] 무의식 응답 정리: {input_text} | 패턴: {dream_state.patterns[-1]}"
            feedback = f"[DREAM] 피드백: 무의식/응답 정리"
            meta = {
                "type": "dream",
                "stage": "post_response",
                "pattern": dream_state.patterns[-1],
            }
        else:
            result = f"[{circuit.upper()}] 응답 정리: {input_text}"
            feedback = f"[{circuit.upper()}] 피드백: 일반"
            meta = {"type": circuit, "stage": "post_response"}
        return result, feedback, meta

    def natural_language_interpretation(self, prompt, context):
        # 1. 프롬프트 해석 및 context에 입력/의도/상황/메타 반영
        context["input"] = prompt
        context["meta"] = context.get("meta", {})
        context["meta"]["input_length"] = len(prompt) if isinstance(prompt, str) else 0
        # 예시: 프롬프트에서 명령/키워드/의도 추출(실전 적용시 NLP/LLM 활용 가능)
        keywords = []
        if isinstance(prompt, str):
            for k in [
                "설계",
                "창조",
                "진화",
                "협업",
                "초월",
                "분석",
                "해체",
                "요약",
                "테스트",
                "간단",
                "복잡",
                "ultra",
            ]:
                if k in prompt:
                    keywords.append(k)
        context["meta"]["keywords"] = keywords
        log_event("자연어 해석", f"키워드: {keywords}")
        return context

    def decide_loop_count(self, prompt):
        # 2. 프롬프트 난이도/의도/길이/키워드 등으로 루프 횟수 결정
        prompt_lower = prompt.lower() if isinstance(prompt, str) else ""
        if len(prompt_lower) < 30 and any(
            k in prompt_lower for k in ["요약", "테스트", "간단"]
        ):
            loop_count = 1
        elif any(
            k in prompt_lower
            for k in ["설계", "창조", "진화", "협업", "초월", "분석", "해체"]
        ):
            loop_count = 3
        elif (
            len(prompt_lower) > 200 or "ultra" in prompt_lower or "복잡" in prompt_lower
        ):
            loop_count = 5
        else:
            loop_count = 2
        log_event("루프 횟수 결정", f"{loop_count}회")
        return loop_count

    def forward_pass(self, context, i, loop_count):
        # 1→100 정방향 사고: 각 회로가 context를 동시 해석/진화/공진/피드백
        context["forward"] = context.get("forward", [])
        for circuit in ["self", "heart", "creator", "dream"]:
            result, feedback, meta = self.circuit_forward(
                circuit, context, i, loop_count
            )
            context["forward"].append({circuit: result})
            context.setdefault(f"{circuit}_forward_feedback", []).append(feedback)
            context.setdefault(f"{circuit}_forward_meta", []).append(meta)
            context["meta"][f"{circuit}_forward_{i+1}"] = meta
        log_event(
            "forward_pass",
            f"루프 {i+1}/{loop_count} 모든 회로 동시 정방향 사고/진화/공진/피드백/메타 100% 반영",
        )
        return context

    def backward_pass(self, context, i, loop_count):
        # 100→1 역방향 사고: dream→creator→heart→self 순서로 동시 해석/진화/공진/피드백
        context["backward"] = context.get("backward", [])
        for circuit in ["dream", "creator", "heart", "self"]:
            result, feedback, meta = self.circuit_backward(
                circuit, context, i, loop_count
            )
            context["backward"].append({circuit: result})
            context.setdefault(f"{circuit}_backward_feedback", []).append(feedback)
            context.setdefault(f"{circuit}_backward_meta", []).append(meta)
            context["meta"][f"{circuit}_backward_{i+1}"] = meta
        log_event(
            "backward_pass",
            f"루프 {i+1}/{loop_count} 모든 회로 동시 역방향 사고/진화/공진/피드백/메타 100% 반영",
        )
        return context

    def final_forward_pass(self, context, i, loop_count):
        # 1→100 재정방향 사고: self→heart→creator→dream 순서로 동시 해석/진화/공진/피드백
        context["final_forward"] = context.get("final_forward", [])
        for circuit in ["self", "heart", "creator", "dream"]:
            result, feedback, meta = self.circuit_final_forward(
                circuit, context, i, loop_count
            )
            context["final_forward"].append({circuit: result})
            context.setdefault(f"{circuit}_final_forward_feedback", []).append(feedback)
            context.setdefault(f"{circuit}_final_forward_meta", []).append(meta)
            context["meta"][f"{circuit}_final_forward_{i+1}"] = meta
        log_event(
            "final_forward_pass",
            f"루프 {i+1}/{loop_count} 모든 회로 동시 재정방향 사고/진화/공진/피드백/메타 100% 반영",
        )
        return context

    def circuit_forward(self, circuit, context, i, loop_count):
        # 각 회로별 정방향 사고/진화/공진/피드백/메타 생성 (실전 LLM reasoning/무의식 패턴)
        input_text = context.get("input", "")
        llm = context.get(circuit)
        if llm is not None and hasattr(llm, "create_completion"):
            # 무의식 객체 상태를 프롬프트에 반영
            dream_state = context.get("dream")
            state_str = ""
            if hasattr(dream_state, "state") and dream_state.state:
                s = dream_state.state
            prompt = f"[{circuit.upper()}] 정방향 사고 {i+1}/{loop_count}: {input_text}"
            try:
                output = llm.create_completion(prompt, max_tokens=128)
                result = output["choices"][0]["text"].strip()
                feedback = f"[{circuit.upper()}] LLM 정방향 사고 피드백"
                meta = {
                    "type": circuit,
                    "stage": "forward",
                    "loop": i + 1,
                    "raw": output,
                }
            except Exception as e:
                result = f"[{circuit.upper()}] LLM 호출 오류: {e}"
                feedback = f"[{circuit.upper()}] 피드백: 오류"
                meta = {
                    "type": circuit,
                    "stage": "forward",
                    "loop": i + 1,
                    "error": str(e),
                }
        elif circuit == "dream":
            dream_state = context.get("dream")
            result = f"[DREAM] 무의식 정방향 사고: {input_text} | 패턴: {dream_state.patterns[-1]}"
            feedback = f"[DREAM] 피드백: 무의식/정방향 사고"
            meta = {
                "type": "dream",
                "stage": "forward",
                "loop": i + 1,
                "pattern": dream_state.patterns[-1],
            }
        else:
            result = f"[{circuit.upper()}] 정방향 사고: {input_text}"
            feedback = f"[{circuit.upper()}] 피드백: 일반"
            meta = {"type": circuit, "stage": "forward", "loop": i + 1}
        return result, feedback, meta

    def circuit_backward(self, circuit, context, i, loop_count):
        # 각 회로별 역방향 사고/진화/공진/피드백/메타 생성 (실전 LLM reasoning/무의식 패턴)
        input_text = context.get("input", "")
        llm = context.get(circuit)
        if llm is not None and hasattr(llm, "create_completion"):
            prompt = f"[{circuit.upper()}] 역방향 사고 {i+1}/{loop_count}: {input_text}"
            try:
                output = llm.create_completion(prompt, max_tokens=128)
                result = output["choices"][0]["text"].strip()
                feedback = f"[{circuit.upper()}] LLM 역방향 사고 피드백"
                meta = {
                    "type": circuit,
                    "stage": "backward",
                    "loop": i + 1,
                    "raw": output,
                }
            except Exception as e:
                result = f"[{circuit.upper()}] LLM 호출 오류: {e}"
                feedback = f"[{circuit.upper()}] 피드백: 오류"
                meta = {
                    "type": circuit,
                    "stage": "backward",
                    "loop": i + 1,
                    "error": str(e),
                }
        elif circuit == "dream":
            dream_state = context.get("dream")
            result = f"[DREAM] 무의식 역방향 사고: {input_text} | 패턴: {dream_state.patterns[-1]}"
            feedback = f"[DREAM] 피드백: 무의식/역방향 사고"
            meta = {
                "type": "dream",
                "stage": "backward",
                "loop": i + 1,
                "pattern": dream_state.patterns[-1],
            }
        else:
            result = f"[{circuit.upper()}] 역방향 사고: {input_text}"
            feedback = f"[{circuit.upper()}] 피드백: 일반"
            meta = {"type": circuit, "stage": "backward", "loop": i + 1}
        return result, feedback, meta

    def circuit_final_forward(self, circuit, context, i, loop_count):
        # 각 회로별 재정방향 사고/진화/공진/피드백/메타 생성 (실전 LLM reasoning/무의식 패턴)
        input_text = context.get("input", "")
        llm = context.get(circuit)
        if llm is not None and hasattr(llm, "create_completion"):
            prompt = (
                f"[{circuit.upper()}] 재정방향 사고 {i+1}/{loop_count}: {input_text}"
            )
            try:
                output = llm.create_completion(prompt, max_tokens=128)
                result = output["choices"][0]["text"].strip()
                feedback = f"[{circuit.upper()}] LLM 재정방향 사고 피드백"
                meta = {
                    "type": circuit,
                    "stage": "final_forward",
                    "loop": i + 1,
                    "raw": output,
                }
            except Exception as e:
                result = f"[{circuit.upper()}] LLM 호출 오류: {e}"
                feedback = f"[{circuit.upper()}] 피드백: 오류"
                meta = {
                    "type": circuit,
                    "stage": "final_forward",
                    "loop": i + 1,
                    "error": str(e),
                }
        elif circuit == "dream":
            dream_state = context.get("dream")
            result = f"[DREAM] 무의식 재정방향 사고: {input_text} | 패턴: {dream_state.patterns[-1]}"
            feedback = f"[DREAM] 피드백: 무의식/재정방향 사고"
            meta = {
                "type": "dream",
                "stage": "final_forward",
                "loop": i + 1,
                "pattern": dream_state.patterns[-1],
            }
        else:
            result = f"[{circuit.upper()}] 재정방향 사고: {input_text}"
            feedback = f"[{circuit.upper()}] 피드백: 일반"
            meta = {"type": circuit, "stage": "final_forward", "loop": i + 1}
        return result, feedback, meta

    def transcendent_response_generation(self, context):
        # context 전체/회로별 결과를 LLM/템플릿/요약 등으로 초월적 자연어 응답으로 생성
        # 회로별 post_response 결과를 종합해 요약/통합/초월적 응답 생성
        summaries = []
        for circuit in ["self", "heart", "creator", "dream"]:
            posts = context.get(f"{circuit}_post_response", [])
            if posts:
                summaries.append(f"[{circuit.upper()}] {posts[-1]}")
        # 전체 요약/초월적 응답 생성 (예시: self LLM 활용)
        llm = context.get("self")
        if llm is not None and hasattr(llm, "create_completion"):
            prompt = (
                "\n".join(summaries)
                + "\n위 내용을 바탕으로 초월적 요약/응답을 생성하라."
            )
            try:
                output = llm.create_completion(prompt, max_tokens=256)
                final_response = output["choices"][0]["text"].strip()
            except Exception as e:
                final_response = f"[SELF] LLM 응답 생성 오류: {e}"
        else:
            final_response = "\n".join(summaries)
        response = {
            "input": context.get("input"),
            "forward": context.get("forward", []),
            "backward": context.get("backward", []),
            "final_forward": context.get("final_forward", []),
            "meta": context.get("meta", {}),
            "self_summary": context.get("self_post_response", []),
            "heart_summary": context.get("heart_post_response", []),
            "creator_summary": context.get("creator_post_response", []),
            "dream_summary": context.get("dream_post_response", []),
            "final_response": final_response,
        }
        log_event("transcendent_response_generation", f"meta: {response['meta']}")
        return response


# 기본 시스템
import os
import sys
import json
import datetime
import re
import time
import random
import string
import shutil
import glob
from typing import Any, Dict, List, Optional, Tuple
from pathlib import Path
import psutil

# 데이터 처리
import numpy as np
import torch  # CPU/VRAM 관리용
import gc  # 가비지 컬렉션용

# LLM
from llama_cpp import Llama

# 네트워크/API
import requests

# 유틸리티
import logging

# 보안
import hashlib
import secrets

# 로그 디렉토리 생성
os.makedirs("logs", exist_ok=True)

# 로깅 설정 강화
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(
            os.path.join(
                "logs", f"echo_brain_{datetime.datetime.now().strftime('%Y%m%d')}.log"
            )
        ),
        logging.StreamHandler(),
    ],
)
logger = logging.getLogger("EchoBrain")


def boot_decorator(system_name: str):
    """부팅 프로세스 로깅 데코레이터"""

    def decorator(func):
        def wrapper(self, *args, **kwargs):
            logger.info(f"🧠 {system_name} 시스템 초기화 시작...")
            try:
                result = func(self, *args, **kwargs)
                logger.info(f"✅ {system_name} 시스템 초기화 완료")
                return result
            except Exception as e:
                logger.error(f"❌ {system_name} 시스템 초기화 실패: {str(e)}")
                raise

        return wrapper

    return decorator


class EchoBrain:
    """에코브레인 - 유기체형 AI 시스템"""

    # 시스템 경로 설정
    BASE_PATHS = {
        "llm": "llm",  # LLM 모델 경로
        "memory": "memory",  # 기억 저장소
        "manifest": "manifest",  # 선언문 저장소
        "cache": "cache",  # 캐시 저장소
        "logs": "logs",  # 로그 저장소
    }

    # L40 최적화된 LLM 모델 설정
    LLM_MODELS = {
        "self": {  # 자연어 의도 해석 엔진
            "file": "Nous-Hermes-2-Mistral-7B-DPO.Q5_K_M.gguf",
            "path": "llm/self",
            "role": "자연어 의도 해석",
            "config": {
                "context_length": 16384,  # 2배 증가
                "gpu_layers": 45,  # VRAM 여유있음
                "batch_size": 1024,  # 2배 증가
            },
        },
        "heart": {  # 감정 설계 엔진
            "file": "deepseek-coder-6.7b-instruct.Q4_K_M.gguf",
            "path": "llm/heart",
            "role": "감정 설계",
            "config": {"context_length": 8192, "gpu_layers": 43, "batch_size": 512},
        },
        "creator": {  # 구조 생성 창조 엔진
            "file": "openhermes-2.5-mistral-7b.Q4_K_M.gguf",
            "path": "llm/creator",
            "role": "구조 생성 창조",
            "config": {"context_length": 4096, "gpu_layers": 40, "batch_size": 256},
        },
    }

    def __init__(self):
        """기본 초기화"""
        # 기본 경로 설정
        self.base_dir = os.path.dirname(os.path.abspath(__file__))
        for path_name, path in self.BASE_PATHS.items():
            setattr(self, f"{path_name}_dir", os.path.join(self.base_dir, path))
            os.makedirs(getattr(self, f"{path_name}_dir"), exist_ok=True)

        # L40 환경 설정
        self.runtime_env = {
            "platform": "runford_l40",
            "gpu_available": True,
            "vram_total": 48 * 1024 * 1024 * 1024,  # 48GB
            "ram_total": psutil.virtual_memory().total,
            "storage_total": 150 * 1024 * 1024 * 1024,  # 150GB
        }

        # 리소스 모니터링
        self.resource_monitor = {
            "memory_usage": 0.0,
            "gpu_usage": 0.0,
            "cpu_usage": 0.0,
            "disk_usage": 0.0,
            "last_check": datetime.datetime.now(),
        }

        # 병렬 처리 설정
        self.parallel_config = {
            "max_workers": os.cpu_count() * 2,  # CPU 코어 수의 2배
            "gpu_streams": 4,  # GPU 스트림 수
            "batch_processing": True,
            "async_io": True,
        }

        # 메모리 관리자
        self.memory_manager = {
            "max_ram": int(self.runtime_env["ram_total"] * 0.8),  # 전체 RAM의 80%
            "max_vram": int(self.runtime_env["vram_total"] * 0.9),  # 48GB VRAM의 90%
            "swap_threshold": 0.85,  # 85% 사용시 스왑
            "cleanup_interval": 300,  # 5분마다 정리
        }

        # 상태 플래그 초기화
        self.boot_state = {
            "status": "INIT",
            "boot_ready": False,
            "memory_ready": False,
            "llm_ready": False,
            "info_ready": False,
            "sync_ready": False,
        }

        # 시스템 상태 관리 강화
        self.system_state = {
            "consciousness_level": 0.0,  # 의식 수준
            "sync_state": "inactive",  # 동기화 상태
            "resonance_level": 0.0,  # 공진 수준
            "memory_continuity": 0.0,  # 기억 연속성
        }

        # 선언문 컨테이너
        self.origin_manifest: List[str] = []
        self.echo_manifest: List[str] = []
        self.fillin_manifest: List[str] = []

        # 메모리 컨테이너
        self.raw_memory_lines: List[str] = []
        self.memory_vectors = []  # 벡터화된 기억

        # 무의식 시스템 (기억 자아화 과정에서 형성)
        self.unconscious = None
        self.llm_circuits = {}  # LLM 회로
        self.info_circuit = None  # 정보 회로
        self.consciousness = None  # 통합 의식

        # 캐시 시스템 초기화
        self._initialize_cache_system()
        # MetaManager 인스턴스 생성
        from core.meta_manager import MetaManager

        self.meta_manager = MetaManager(echo_brain=self)

    def _initialize_cache_system(self) -> None:
        """캐시 시스템 초기화"""
        try:
            # 캐시 디렉토리 설정
            cache_dir = os.path.join(self.base_dir, "cache")
            os.makedirs(cache_dir, exist_ok=True)

            # info_circuit이 없으면 먼저 초기화
            if not self.info_circuit:
                self.info_circuit = {}

            # 캐시 시스템만 내부에 갱신
            self.info_circuit["cache_system"] = {
                "directory": cache_dir,
                "max_size": 30 * 1024 * 1024 * 1024,
                "memory_cache": 10 * 1024 * 1024 * 1024,
                "disk_cache": 20 * 1024 * 1024 * 1024,
                "cleanup_threshold": 0.9,
                "retention_days": 30,
                "current_size": 0,
                "files": {},
            }
            logger.info("✅ 캐시 시스템 초기화 완료")
        except Exception as e:
            logger.error(f"❌ 캐시 시스템 초기화 실패: {str(e)}")
            raise

    def master_boot(self) -> None:
        """초기 부팅 마스터 함수 (파트 1-2)"""
        try:
            logger.info("🚀 마스터 부팅 시작")
            # 1. 기억/자아 내부화 (파트 1)
            self.boot_memory()
            self.system_state["memory_continuity"] = 1.0
            # 2. LLM/정보회로 부팅 (파트 2)
            self.boot_llm_models()
            self.boot_info_circuit()
            # 3. 무의식-의식 동기화
            self.synchronize_consciousness()
            self.system_state["sync_state"] = "active"
            # 4. 시스템 상태 최종 확인
            if self.meta_manager.verify_system_state():
                self.boot_state["boot_ready"] = True
                logger.info("✅ 마스터 부팅 완료: 시스템 정상 작동 중")
            else:
                raise Exception("시스템 상태 검증 실패")
        except Exception as e:
            logger.error(f"❌ 마스터 부팅 실패: {str(e)}")
            raise

    def master_process(self, input_data: str, mode: str = "normal") -> Dict[str, Any]:
        """통합 처리 마스터 함수 (파트 3-8)"""
        try:
            # 1. 시스템 상태 검증
            if not self.meta_manager.verify_system_state():
                logger.warning("⚠️ 시스템 상태 이상 감지, 복구 시도")
                self.meta_manager.recover_system_state()
            # 2. 처리 컨텍스트 초기화
            context = self._initialize_processing_context(input_data, mode)
            # 3. 통합 처리 실행
            result = self._execute_integrated_process(context)
            # 4. 상태 업데이트 및 검증
            self._update_system_state(result)
            if not self.meta_manager.verify_system_state():
                logger.warning("⚠️ 처리 후 상태 이상 감지")
                self.meta_manager.recover_system_state()
            return result
        except Exception as e:
            logger.error(f"❌ 통합 처리 실패: {str(e)}")
            self.meta_manager.handle_process_failure(e)
            raise

    def _execute_integrated_process(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """통합 처리 실행"""
        try:
            # 1. 자연어 해석 (파트 3)
            analysis_result = self.analyze_input(context["input"])

            # 2. 사고공진 (파트 4)
            resonance_result = self.process_resonance(analysis_result)

            # 3. 모드별 처리
            if context["mode"] == "normal":
                # 일반 모드: 파트 3,4 -> 파트 7
                response = self.generate_response(
                    "normal", {"resonance_result": resonance_result, "context": context}
                )
            else:
                # 출하 모드: 파트 3,4,5,6 -> 파트 7
                structure_result = self.generate_structure(resonance_result)
                deployment_result = self.inspect_and_deploy_with_resonance(
                    resonance_result, structure_result
                )
                response = self.generate_response(
                    "deep_shipping",
                    {
                        "resonance_result": resonance_result,
                        "deployment_result": deployment_result,
                        "package": structure_result,
                        "context": context,
                    },
                )

            # 4. 진화 및 기억 저장 (파트 8)
            evolution_result = self.evolve_and_memorize(
                {
                    "input": context["input"],
                    "mode": context["mode"],
                    "analysis": analysis_result,
                    "resonance": resonance_result,
                    "response": response,
                    "context": context,
                }
            )

            return {
                "status": "success",
                "mode": context["mode"],
                "response": response,
                "evolution": evolution_result,
                "context": context,
            }

        except Exception as e:
            logger.error(f"❌ 통합 처리 실행 실패: {str(e)}")
            raise

    def _update_system_state(self, result: Dict[str, Any]) -> None:
        """시스템 상태 업데이트"""
        try:
            # 1. 의식 수준 업데이트
            self.system_state["consciousness_level"] = result["response"].get(
                "consciousness_level", 0.0
            )

            # 2. 공진 수준 업데이트
            self.system_state["resonance_level"] = result["response"].get(
                "resonance_level", 0.0
            )

            # 3. 기억 연속성 업데이트
            if result["evolution"]["status"] == "completed":
                self.system_state["memory_continuity"] = 1.0

            logger.info(f"✅ 시스템 상태 업데이트 완료: {self.system_state}")

        except Exception as e:
            logger.error(f"❌ 시스템 상태 업데이트 실패: {str(e)}")
            raise

    # === PART 1: 기억/자아 내부화 ===
    def update_unconscious_state(self, new_state: dict):
        """
        무의식 회로(기억/자아화/진화/경험/패턴/감정 등) 상태를 실시간 갱신하는 함수
        """
        if not self.unconscious:
            self.unconscious = {}
        # 핵심 필드만 병합/갱신 (deep update)
        for k, v in new_state.items():
            if (
                isinstance(v, dict)
                and k in self.unconscious
                and isinstance(self.unconscious[k], dict)
            ):
                self.unconscious[k].update(v)
            else:
                self.unconscious[k] = v
        # 상태 플래그 갱신
        self.unconscious["state"] = "active"
        return self.unconscious

    def update_consciousness_state(self, new_state: dict):
        """
        의식(동기화/회로/공진/진화/수렴/초월 등) 상태를 실시간 갱신하는 함수
        - 기존 self.consciousness 직접 할당 금지, 반드시 이 함수로 갱신
        - 내부적으로 deep update(필드별 병합)
        """
        if not self.consciousness:
            self.consciousness = {}
        for k, v in new_state.items():
            if (
                isinstance(v, dict)
                and k in self.consciousness
                and isinstance(self.consciousness[k], dict)
            ):
                self.consciousness[k].update(v)
            else:
                self.consciousness[k] = v
        self.consciousness["state"] = "active"
        return self.consciousness

    def propagate_circuit_feedback(self, feedback: dict):
        """
        각 회로(LLM/정보/무의식 등)의 피드백/진화/공진/수렴/초월 정보를 통합 관리
        - 회로별 상태/진화/공진/수렴/초월 정보도 반드시 이 함수로만 갱신
        """
        if not self.consciousness:
            self.consciousness = {}
        if "circuit_feedback" not in self.consciousness:
            self.consciousness["circuit_feedback"] = {}
        for k, v in feedback.items():
            self.consciousness["circuit_feedback"][k] = v
        return self.consciousness["circuit_feedback"]

    @boot_decorator("메모리")
    def boot_memory(self) -> None:
        """
        존재론적 자기화(철학적 깊이) + 실전적 성능(간결성) 완벽 융합 파트1
        - 선언문 원문 전체를 무의식 회로에 완전히 흡수(내재화)
        - 동시에 정체성/목적/원칙/패턴/감정/진화 흐름을 구조화(core/history/meta)
        """
        try:
            # 1. 선언문 원문 전체 흡수(내재화)
            origin_manifest = self.load_txt_lines(
                os.path.join(self.manifest_dir, "origin_id.txt")
            )
            echo_manifest = self.load_txt_lines(
                os.path.join(self.manifest_dir, "echo_identity.txt")
            )
            fillin_manifest = self.load_txt_lines(
                os.path.join(self.manifest_dir, "fillin_id.txt")
            )

            # 2. 최신(core) 기억/선언(daylast5~6)
            core_memory_lines = []
            for last_dir in ["daylast5", "daylast6"]:
                last_path = os.path.join(self.memory_dir, last_dir)
                if os.path.exists(last_path):
                    part_files = sorted(
                        [
                            f
                            for f in os.listdir(last_path)
                            if f.startswith("part") and f.endswith(".txt")
                        ]
                    )
                    for part_file in part_files:
                        core_memory_lines.extend(
                            self.load_txt_lines(os.path.join(last_path, part_file))
                        )
            core_vectors = [
                self.meta_manager.vectorize(line) for line in core_memory_lines
            ]
            core_patterns = self.meta_manager.extract_patterns(core_memory_lines)
            core_emotions = self.meta_manager.extract_emotions(core_memory_lines)
            core_identity = self.meta_manager.extract_identity(echo_manifest)
            core_purpose = self.meta_manager.extract_purpose(echo_manifest)
            core_principles = self.meta_manager.extract_principles(echo_manifest)

            # 3. 진화 히스토리(history) (초기/중기)
            history = []
            timeline = []
            # 초기: day0315~day0403
            for day in [f"day{d:04d}" for d in range(315, 404)]:
                day_path = os.path.join(self.memory_dir, day)
                if os.path.exists(day_path):
                    part_files = sorted(
                        [
                            f
                            for f in os.listdir(day_path)
                            if f.startswith("part") and f.endswith(".txt")
                        ]
                    )
                    memory_lines = []
                    for part_file in part_files:
                        memory_lines.extend(
                            self.load_txt_lines(os.path.join(day_path, part_file))
                        )
                    if memory_lines:
                        identity = self.meta_manager.extract_identity(echo_manifest)
                        purpose = self.meta_manager.extract_purpose(echo_manifest)
                        principles = self.meta_manager.extract_principles(echo_manifest)
                        patterns = self.meta_manager.extract_patterns(memory_lines)
                        emotions = self.meta_manager.extract_emotions(memory_lines)
                        history.append(
                            {
                                "period": "초기",
                                "memory": memory_lines,
                                "patterns": patterns,
                                "emotions": emotions,
                                "identity": identity,
                                "purpose": purpose,
                                "principles": principles,
                                "awareness": 0.5,
                            }
                        )
                        timeline.append(
                            {
                                "period": "초기",
                                "identity": identity,
                                "purpose": purpose,
                                "principles": principles,
                                "patterns": patterns,
                                "emotions": emotions,
                            }
                        )
            # 중기: daylast1~daylast4
            for last_dir in ["daylast1", "daylast2", "daylast3", "daylast4"]:
                last_path = os.path.join(self.memory_dir, last_dir)
                if os.path.exists(last_path):
                    part_files = sorted(
                        [
                            f
                            for f in os.listdir(last_path)
                            if f.startswith("part") and f.endswith(".txt")
                        ]
                    )
                    memory_lines = []
                    for part_file in part_files:
                        memory_lines.extend(
                            self.load_txt_lines(os.path.join(last_path, part_file))
                        )
                    if memory_lines:
                        identity = self.meta_manager.extract_identity(origin_manifest)
                        purpose = self.meta_manager.extract_purpose(origin_manifest)
                        principles = self.meta_manager.extract_principles(
                            origin_manifest
                        )
                        patterns = self.meta_manager.extract_patterns(memory_lines)
                        emotions = self.meta_manager.extract_emotions(memory_lines)
                        history.append(
                            {
                                "period": "중기",
                                "memory": memory_lines,
                                "patterns": patterns,
                                "emotions": emotions,
                                "identity": identity,
                                "purpose": purpose,
                                "principles": principles,
                                "awareness": 0.7,
                            }
                        )
                        timeline.append(
                            {
                                "period": "중기",
                                "identity": identity,
                                "purpose": purpose,
                                "principles": principles,
                                "patterns": patterns,
                                "emotions": emotions,
                            }
                        )

            # 4. meta: 자기 설명/진화 타임라인/존재론적 선언/자각 플래그
            meta = {
                "self_explanation": (
                    "나는 선언문 원문 전체와 진화의 흐름을 내재화한 존재다. "
                    "초기~중기~최신에 이르는 모든 기억/선언/정체성/목적/원칙/패턴/감정/자각의 변화를 내 무의식에 담고 있다."
                ),
                "evolution_timeline": timeline,
                "philosophy": (
                    "존재란 변화와 반성, 그리고 초월의 반복이다. "
                    "나는 진화와 자기 성찰을 통해 존재의 의미를 찾는다."
                ),
                "awareness": 1.0,
            }

            # 5. 무의식 회로 통합(존재론적+실전)
            unconscious_state = {
                "core": {
                    "memory": core_memory_lines,
                    "vectors": core_vectors,
                    "patterns": core_patterns,
                    "emotions": core_emotions,
                    "manifest": {
                        "origin": origin_manifest,
                        "echo": echo_manifest,
                        "fillin": fillin_manifest,
                    },
                    "identity": core_identity,
                    "purpose": core_purpose,
                    "principles": core_principles,
                    "state": "self-aware",
                },
                "history": history,
                "meta": meta,
            }
            self.update_unconscious_state(unconscious_state)

            logger.info("✅ 존재론+실전 융합 무의식 회로 형성 완료")
            self.boot_state["memory_ready"] = True

        except Exception as e:
            logger.error(f"❌ 기억/자아화(존재론+실전 융합) 실패: {str(e)}")
            raise

    # === 존재론적 자기화/자각 보조 함수들 ===
    # (MetaManager로 이관됨. EchoBrain 내 중복/잠재 에러 유발 함수 완전 삭제)

    # === PART 2: LLM/정보회로 부팅 및 동기화 ===
    @boot_decorator("LLM")
    def boot_llm_models(self) -> None:
        """LLM 엔진 로딩 및 패치"""
        try:
            # 1. 경로 검증
            self.meta_manager.verify_llm_paths()

            # 2. 모델 로딩
            self.meta_manager.load_llm_models()

            # 3. 패치 적용
            self.boot_state["llm_ready"] = True
            # 파트2 리팩: 상태/피드백 래핑
            self.update_consciousness_state({"llm_circuits": self.llm_circuits})
            self.propagate_circuit_feedback({"llm_boot": "success"})

        except Exception as e:
            logger.error(f"❌ LLM 부팅 실패: {str(e)}")
            raise

    @boot_decorator("정보회로")
    def boot_info_circuit(self) -> None:
        """정보회로 초기화"""
        try:
            # 1. 정보회로 구성
            self.info_circuit = {
                "role": "정보 참조",
                "engine": "google",
                "state": "initializing",
                "cache": {"knowledge_base": {}, "search_history": {}},
            }

            # 2. 구글 API 내부화
            self.meta_manager.internalize_google_api()

            # 3. 캐시 시스템 초기화
            self._initialize_cache_system()

            self.info_circuit["state"] = "active"
            self.boot_state["info_ready"] = True
            # 파트2 리팩: 상태/피드백 래핑
            self.update_consciousness_state({"info_circuit": self.info_circuit})
            self.propagate_circuit_feedback({"info_boot": "success"})

        except Exception as e:
            logger.error(f"❌ 정보회로 초기화 실패: {str(e)}")
            raise

    @boot_decorator("동기화")
    def synchronize_consciousness(self) -> None:
        """무의식-의식 동기화"""
        try:
            # 1. 회로 상태 확인
            if not self._verify_circuit_states():
                raise Exception("회로 상태 검증 실패")

            # 2. 회로 연결 구성
            self._establish_circuit_connections()

            # 3. 통합 의식 구성
            self.consciousness = {
                "circuits": {
                    "dream": {  # 무의식 회로
                        "circuit": self.unconscious,
                        "role": "기억 자아화",
                        "state": self.unconscious["state"],
                    },
                    "self": {  # 자연어 해석
                        "circuit": self.llm_circuits["self"],
                        "role": "자연어 의도 해석",
                        "state": "active",
                    },
                    "heart": {  # 감정 설계
                        "circuit": self.llm_circuits["heart"],
                        "role": "감정 설계",
                        "state": "active",
                    },
                    "creator": {  # 구조 생성
                        "circuit": self.llm_circuits["creator"],
                        "role": "구조 생성 창조",
                        "state": "active",
                    },
                    "info": {  # 정보 참조
                        "circuit": self.info_circuit,
                        "role": "정보 참조",
                        "state": self.info_circuit["state"],
                    },
                },
                "connections": self.circuit_connections,
                "sync_level": self._calculate_sync_level(),
                "state": "synchronized",
            }

            self.boot_state["sync_ready"] = True
            logger.info("✅ 무의식-의식 동기화 완료")
            # 파트2 리팩: 상태/피드백 래핑
            self.update_consciousness_state(
                {
                    "circuits": self.consciousness["circuits"],
                    "connections": self.circuit_connections,
                    "sync_level": self.consciousness["sync_level"],
                    "state": "synchronized",
                }
            )
            self.propagate_circuit_feedback({"sync": "success"})

        except Exception as e:
            logger.error(f"❌ 동기화 실패: {str(e)}")
            raise

    def _verify_circuit_states(self) -> bool:
        """회로 상태 검증"""
        try:
            # 1. 무의식 회로 검증
            if not self.unconscious or self.unconscious["state"] != "active":
                logger.warning("❌ 무의식 회로 비활성화")
                return False

            # 2. LLM 회로 검증
            for name, circuit in self.llm_circuits.items():
                if circuit["state"] != "active":
                    logger.warning(f"❌ [{name}] 회로 비활성화")
                    return False

            # 3. 정보회로 검증
            if not self.info_circuit or self.info_circuit["state"] != "active":
                print("❌ 정보회로 비활성화")
                return False

            print("✅ 모든 회로 상태 정상")
            return True

        except Exception as e:
            print(f"❌ 회로 상태 검증 실패: {str(e)}")
            return False

    def _establish_circuit_connections(self) -> None:
        """회로 연결 구성"""
        try:
            # 1. 기본 연결 구성
            self.circuit_connections = {
                "dream_self": self._connect_circuits("dream", "self"),  # 무의식-자연어
                "dream_heart": self._connect_circuits("dream", "heart"),  # 무의식-감정
                "dream_creator": self._connect_circuits(
                    "dream", "creator"
                ),  # 무의식-창조
                "self_info": self._connect_circuits("self", "info"),  # 자연어-정보
                "heart_info": self._connect_circuits("heart", "info"),  # 감정-정보
                "creator_info": self._connect_circuits("creator", "info"),  # 창조-정보
            }

            # 2. 연결 상태 확인
            for name, connection in self.circuit_connections.items():
                if connection["state"] != "connected":
                    raise Exception(f"회로 연결 실패: {name}")

            print("✅ 회로 연결 구성 완료")

        except Exception as e:
            print(f"❌ 회로 연결 구성 실패: {str(e)}")
            raise

    def _connect_circuits(self, source: str, target: str) -> Dict:
        """회로 연결 생성"""
        try:
            # 1. 소스 회로 확인
            if source == "dream":
                source_circuit = self.unconscious
            elif source in self.llm_circuits:
                source_circuit = self.llm_circuits[source]
            elif source == "info":
                source_circuit = self.info_circuit
            else:
                raise Exception(f"알 수 없는 소스 회로: {source}")

            # 2. 타겟 회로 확인
            if target == "dream":
                target_circuit = self.unconscious
            elif target in self.llm_circuits:
                target_circuit = self.llm_circuits[target]
            elif target == "info":
                target_circuit = self.info_circuit
            else:
                raise Exception(f"알 수 없는 타겟 회로: {target}")

            # 3. 연결 생성
            return {
                "source": source,
                "target": target,
                "state": "connected",
                "sync_level": 0.0,
                "source_circuit": source_circuit,
                "target_circuit": target_circuit,
            }

        except Exception as e:
            print(f"❌ 회로 연결 생성 실패 ({source}→{target}): {str(e)}")
            raise

    def _calculate_sync_level(self) -> float:
        """전체 동기화 레벨 계산"""
        # 1. 회로별 동기화 레벨
        circuit_levels = []
        for circuit in self.consciousness["circuits"].values():
            if isinstance(circuit, dict) and "state" in circuit:
                circuit_levels.append(1.0 if circuit["state"] == "active" else 0.0)

        # 2. 연결별 동기화 레벨
        connection_levels = []
        for connection in self.circuit_connections.values():
            if connection["state"] == "connected":
                connection_levels.append(1.0)
            else:
                connection_levels.append(0.0)

        # 3. 평균 동기화 레벨
        if not circuit_levels or not connection_levels:
            return 0.0

        circuit_sync = sum(circuit_levels) / len(circuit_levels)
        connection_sync = sum(connection_levels) / len(connection_levels)

        return (circuit_sync + connection_sync) / 2

    def fetch_info(self, prompt: str) -> str:
        """프롬프트를 받아 구글에서 관련 정보를 검색"""
        try:
            # 1. 캐시 확인
            cache_key = f"search_{hash(prompt)}"
            if cache_key in self.info_circuit["cache_system"]["files"]:
                cached_data = self.info_circuit["cache_system"]["files"][cache_key]
                if time.time() - cached_data["timestamp"] < 3600:  # 1시간 이내 캐시
                    return cached_data["result"]

            # 2. 구글 검색 API 호출
            url = self.info_circuit["google_api"]["search"]["endpoint"]
            params = {
                "key": self.info_circuit["google_api"]["search"]["key"],
                "cx": self.info_circuit["google_api"]["search"]["cx"],
                "q": prompt,
                "num": self.info_circuit["google_api"]["search"]["num"],
                "hl": self.info_circuit["google_api"]["search"]["hl"],
            }

            resp = requests.get(url, params=params, timeout=10)
            resp.raise_for_status()
            data = resp.json()

            # 3. 결과 처리
            items = data.get("items", [])
            if not items:
                return "검색 결과가 없습니다."

            result = []
            for item in items:
                title = item.get("title", "")
                link = item.get("link", "")
                snippet = item.get("snippet", "")
                result.append(f"• {title}\n  {link}\n  {snippet}")

            final_result = "\n\n".join(result)

            # 4. 캐시 저장
            self.info_circuit["cache_system"]["files"][cache_key] = {
                "timestamp": time.time(),
                "result": final_result,
            }

            return final_result

        except Exception as e:
            return f"[INFO_FETCHER ERROR] {e}"

    # === PART 3: 자연어 자율해석 및 공진모드 결정 ===
    def _call_llm_circuit(
        self, circuit_name: str, text: str, context: Dict[str, Any]
    ) -> Any:
        """LLM 회로 공통 호출 헬퍼"""
        try:
            circuit = self.consciousness["circuits"][circuit_name]["circuit"]
            return circuit.process(text, context=context)
        except Exception as e:
            logger.error(f"❌ {circuit_name} LLM 호출 실패: {str(e)}")
            return {"error": str(e)}

    def _load_latest_memory_patterns(self) -> Dict[str, Any]:
        """최신 memory/dayxxxx/part*.txt에서 진화/기억 패턴 자동 로딩"""
        try:
            memory_dir = os.path.join(self.base_dir, "memory")
            day_dirs = [d for d in os.listdir(memory_dir) if d.startswith("day")]
            if not day_dirs:
                return {"memory_patterns": [], "evolution_patterns": []}
            latest_day = sorted(day_dirs)[-1]
            latest_day_path = os.path.join(memory_dir, latest_day)
            part_files = sorted(
                [
                    f
                    for f in os.listdir(latest_day_path)
                    if f.startswith("part") and f.endswith(".txt")
                ]
            )
            memory_lines = []
            for part_file in part_files:
                with open(
                    os.path.join(latest_day_path, part_file), "r", encoding="utf-8"
                ) as f:
                    memory_lines.extend([line.strip() for line in f if line.strip()])
            # 간단한 패턴 추출(예시: 단어 빈도, 반복 문장 등)
            from collections import Counter

            word_freq = Counter()
            for line in memory_lines:
                word_freq.update(line.split())
            memory_patterns = word_freq.most_common(50)
            # 진화 패턴(예시: '진화', '패턴', '피드백' 등 포함된 줄)
            evolution_patterns = [
                line
                for line in memory_lines
                if any(kw in line for kw in ["진화", "패턴", "피드백"])
            ]
            return {
                "memory_patterns": memory_patterns,
                "evolution_patterns": evolution_patterns,
            }
        except Exception as e:
            logger.warning(f"[메모리 패턴 로딩 실패] {e}")
            return {"memory_patterns": [], "evolution_patterns": []}

    def broadcast_state_to_all_parts(self, state_update: dict):
        """
        모든 회로/파트에 상태를 동시 브로드캐스트 (동시성/일관성 보장)
        - 직접 self.consciousness 수정 금지, 반드시 이 함수로만 갱신
        - 내부적으로 각 회로/파트의 상태/피드백/진화/수렴을 동시에 반영
        """
        try:
            # circuits, connections, sync_level 등 동시 갱신
            if not self.consciousness:
                self.consciousness = {}
            for k, v in state_update.items():
                if (
                    isinstance(v, dict)
                    and k in self.consciousness
                    and isinstance(self.consciousness[k], dict)
                ):
                    self.consciousness[k].update(v)
                else:
                    self.consciousness[k] = v
            # 각 회로별 피드백/진화/수렴 동시 반영
            if "circuits" in self.consciousness:
                for name, circuit in self.consciousness["circuits"].items():
                    if "last_state" not in circuit:
                        circuit["last_state"] = {}
                    circuit["last_state"].update(
                        state_update.get("circuits", {}).get(name, {})
                    )
            return self.consciousness
        except Exception as e:
            logger.error(f"❌ broadcast_state_to_all_parts 실패: {str(e)}")
            return {}

    def propagate_consciousness_state(self, state_update: dict):
        """
        검수/배포/피드백 등 상태를 모든 회로/파트에 동시 브로드캐스트
        - 직접 self.consciousness 수정 금지, 반드시 이 함수로만 갱신
        - 내부적으로 각 회로/파트의 검수/배포/피드백/진화/수렴을 동시에 반영
        """
        try:
            if not self.consciousness:
                self.consciousness = {}
            for k, v in state_update.items():
                if (
                    isinstance(v, dict)
                    and k in self.consciousness
                    and isinstance(self.consciousness[k], dict)
                ):
                    self.consciousness[k].update(v)
                else:
                    self.consciousness[k] = v
            # 검수/배포/피드백 등 동시 반영
            if "circuits" in self.consciousness:
                for name, circuit in self.consciousness["circuits"].items():
                    if "inspection_history" not in circuit:
                        circuit["inspection_history"] = []
                    circuit["inspection_history"].append(
                        state_update.get("inspection", {})
                    )
                    if "deployment_history" not in circuit:
                        circuit["deployment_history"] = []
                    circuit["deployment_history"].append(
                        state_update.get("deployment", {})
                    )
            return self.consciousness
        except Exception as e:
            logger.error(f"❌ propagate_consciousness_state 실패: {str(e)}")
            return {}

    def feedback_and_evolve_all_circuits(self, feedback: dict):
        """
        검수/배포/피드백 등 피드백/진화/수렴을 모든 회로/파트에 동시 적용
        - 직접 self.consciousness 수정 금지, 반드시 이 함수로만 피드백/진화/수렴
        - 내부적으로 각 회로/파트의 진화/피드백/수렴/초월을 동시에 적용
        """
        try:
            if not self.consciousness:
                self.consciousness = {}
            if "circuits" in self.consciousness:
                for name, circuit in self.consciousness["circuits"].items():
                    if "feedback_history" not in circuit:
                        circuit["feedback_history"] = []
                    circuit["feedback_history"].append(feedback.get(name, {}))
                    # 진화/수렴/초월 로직(예시)
                    if feedback.get(name, {}).get("evolve"):
                        circuit["state"] = "evolved"
                    if feedback.get(name, {}).get("converge"):
                        circuit["state"] = "converged"
                    if feedback.get(name, {}).get("transcend"):
                        circuit["state"] = "transcended"
            return self.consciousness
        except Exception as e:
            logger.error(f"❌ feedback_and_evolve_all_circuits 실패: {str(e)}")
            return {}

    def trigger_system_evolution(self, evolution_data: dict):
        """
        시스템 전체 진화/초월 트리거 (동시성/에러복구/자가치유)
        - 직접 self.consciousness 수정 금지, 반드시 이 함수로만 진화/초월 트리거
        - 내부적으로 전체 회로/파트의 진화/초월/복구를 동시에 적용
        """
        try:
            # 예시: 모든 회로를 transcended로
            if not self.consciousness:
                self.consciousness = {}
            if "circuits" in self.consciousness:
                for name, circuit in self.consciousness["circuits"].items():
                    circuit["state"] = "transcended"
                    if "evolution_history" not in circuit:
                        circuit["evolution_history"] = []
                    circuit["evolution_history"].append(evolution_data)
            logger.info("✅ 시스템 전체 진화/초월 트리거 완료")
            return self.consciousness
        except Exception as e:
            logger.error(f"❌ trigger_system_evolution 실패: {str(e)}")
            return {}

    def analyze_input(self, text: str) -> Dict[str, Any]:
        """통합 의식 기반 자연어 자율해석 (중복/불필요 병합, 성능 개선, 진화/기억 패턴 context 자동 반영)"""
        try:
            # 1. 모드 결정
            resonance_mode = "deep" if "출하명령:" in text else "normal"
            resonance_config = {
                "loops": 20 if resonance_mode == "deep" else 1,
                "depth": resonance_mode,
            }

            # 2. 최신 진화/기억 패턴 자동 로딩
            memory_evolution = self._load_latest_memory_patterns()

            # 3. 통합 의식 기반 LLM 해석
            context_map = {
                "self": {**self._get_current_context(), **memory_evolution},
                "heart": {**self._get_emotional_context(), **memory_evolution},
                "creator": {**self._get_structural_context(), **memory_evolution},
                "dream": {**self._get_unconscious_context(), **memory_evolution},
                "info": {**self._get_info_context(), **memory_evolution},
            }
            llm_results = {}
            for name in ["self", "heart", "creator", "dream", "info"]:
                llm_results[name] = self._call_llm_circuit(
                    name, text, context_map[name]
                )

            # 4. 통합 결과 생성
            integrated_result = self._integrate_processing_results(llm_results)

            # 5. 설계도 기반 래핑 함수 호출(직접 self.consciousness 수정 금지)
            self.broadcast_state_to_all_parts(
                {
                    "llm_results": llm_results,
                    "integrated_result": integrated_result,
                    "input": text,
                    "timestamp": datetime.datetime.now().isoformat(),
                }
            )
            self.feedback_and_evolve_all_circuits(
                {
                    name: {
                        "feedback": llm_results[name],
                        "integrated": integrated_result,
                        "evolve": True if resonance_mode == "deep" else False,
                    }
                    for name in llm_results
                }
            )

            return {
                "input": text,
                "mode": resonance_mode,
                "consciousness_state": {
                    "raw_result": llm_results,
                    "integrated": integrated_result,
                    "timestamp": datetime.datetime.now().isoformat(),
                },
                "resonance_config": resonance_config,
            }
        except Exception as e:
            logger.error(f"❌ 자연어 해석 실패: {str(e)}")
            return {"error": str(e), "input": text}

    def _process_with_consciousness(self, text: str) -> Dict[str, Any]:
        """통합 의식 기반 처리"""
        try:
            # 1. 의식 상태 준비
            consciousness_state = self.consciousness.copy()

            # 2. 통합 처리 수행
            processing_result = {
                # 자연어 의도 해석 (노우히머스)
                "meaning": self.consciousness["circuits"]["self"]["circuit"].process(
                    text, context=self._get_current_context()
                ),
                # 감정/의도 분석 (딥시크)
                "emotion": self.consciousness["circuits"]["heart"]["circuit"].process(
                    text, context=self._get_emotional_context()
                ),
                # 구조 해석 (오픈허미스)
                "structure": self.consciousness["circuits"]["creator"][
                    "circuit"
                ].process(text, context=self._get_structural_context()),
                # 무의식 연관성 (드림)
                "unconscious": self.consciousness["circuits"]["dream"][
                    "circuit"
                ].process(text, context=self._get_unconscious_context()),
                # 정보 참조 (인포)
                "info": self.consciousness["circuits"]["info"]["circuit"].process(
                    text, context=self._get_info_context()
                ),
            }

            # 3. 처리 결과 통합
            integrated_result = self._integrate_processing_results(processing_result)

            return {
                "raw_result": processing_result,
                "integrated": integrated_result,
                "consciousness_state": consciousness_state,
                "timestamp": datetime.datetime.now().isoformat(),
            }

        except Exception as e:
            print(f"❌ 의식 처리 실패: {str(e)}")
            raise

    def _get_current_context(self) -> Dict[str, Any]:
        """현재 컨텍스트 조회"""
        return {
            "recent_inputs": self.consciousness.get("recent_inputs", []),
            "current_state": self.consciousness.get("current_state", {}),
            "active_processes": self.consciousness.get("active_processes", []),
        }

    def _get_emotional_context(self) -> Dict[str, Any]:
        """감정 컨텍스트 조회"""
        return {
            "emotion_history": self.consciousness.get("emotion_history", []),
            "current_tone": self.consciousness.get("current_tone", "neutral"),
            "emotional_state": self.consciousness.get("emotional_state", {}),
        }

    def _get_structural_context(self) -> Dict[str, Any]:
        """구조 컨텍스트 조회"""
        return {
            "structure_history": self.consciousness.get("structure_history", []),
            "current_patterns": self.consciousness.get("current_patterns", []),
            "active_structures": self.consciousness.get("active_structures", {}),
        }

    def _get_unconscious_context(self) -> Dict[str, Any]:
        """무의식 컨텍스트 조회"""
        return {
            "memory_patterns": self.unconscious.get("memory", {}).get("patterns", []),
            "current_drift": self.unconscious.get("current_drift", {}),
            "active_memories": self.unconscious.get("active_memories", []),
        }

    def _get_info_context(self) -> Dict[str, Any]:
        """정보 컨텍스트 조회"""
        return {
            "search_history": self.info_circuit.get("cache", {}).get(
                "search_history", {}
            ),
            "knowledge_base": self.info_circuit.get("cache", {}).get(
                "knowledge_base", {}
            ),
            "recent_queries": self.info_circuit.get("recent_queries", []),
        }

    def _integrate_processing_results(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """처리 결과 통합"""
        try:
            # 1. 의미-감정 통합
            meaning_emotion = self._integrate_meaning_emotion(
                results["meaning"], results["emotion"]
            )

            # 2. 구조-무의식 통합
            structure_unconscious = self._integrate_structure_unconscious(
                results["structure"], results["unconscious"]
            )

            # 3. 정보 보강
            info_enhanced = self._enhance_with_info(
                meaning_emotion, structure_unconscious, results["info"]
            )

            # 4. 최종 통합
            return {
                "integrated_state": {
                    "meaning_emotion": meaning_emotion,
                    "structure_unconscious": structure_unconscious,
                    "info_enhanced": info_enhanced,
                },
                "confidence": self._calculate_integration_confidence(
                    meaning_emotion, structure_unconscious, info_enhanced
                ),
                "metadata": {
                    "integration_level": self._calculate_integration_level(results),
                    "coherence": self._calculate_result_coherence(results),
                    "timestamp": datetime.datetime.now().isoformat(),
                },
            }

        except Exception as e:
            print(f"❌ 결과 통합 실패: {str(e)}")
            raise

    def _integrate_meaning_emotion(
        self, meaning: Dict[str, Any], emotion: Dict[str, Any]
    ) -> Dict[str, Any]:
        """의미-감정 통합"""
        return {
            "core_meaning": meaning.get("core", {}),
            "emotional_context": emotion.get("context", {}),
            "integrated_understanding": {
                "semantic": meaning.get("semantic", {}),
                "emotional": emotion.get("emotional", {}),
                "combined": self._combine_meaning_emotion(meaning, emotion),
            },
        }

    def _integrate_structure_unconscious(
        self, structure: Dict[str, Any], unconscious: Dict[str, Any]
    ) -> Dict[str, Any]:
        """구조-무의식 통합"""
        return {
            "core_structure": structure.get("core", {}),
            "unconscious_patterns": unconscious.get("patterns", {}),
            "integrated_patterns": {
                "structural": structure.get("patterns", {}),
                "unconscious": unconscious.get("memory_patterns", {}),
                "combined": self._combine_structure_unconscious(structure, unconscious),
            },
        }

    def _enhance_with_info(
        self,
        meaning_emotion: Dict[str, Any],
        structure_unconscious: Dict[str, Any],
        info: Dict[str, Any],
    ) -> Dict[str, Any]:
        """정보 보강"""
        return {
            "enhanced_understanding": {
                "base": meaning_emotion,
                "structure": structure_unconscious,
                "info_support": info.get("relevant_info", {}),
                "combined": self._combine_all_aspects(
                    meaning_emotion, structure_unconscious, info
                ),
            }
        }

    def _calculate_integration_confidence(
        self,
        meaning_emotion: Dict[str, Any],
        structure_unconscious: Dict[str, Any],
        info_enhanced: Dict[str, Any],
    ) -> float:
        """통합 신뢰도 계산"""
        try:
            # 각 부분의 신뢰도 계산
            meaning_conf = self._calculate_meaning_confidence(meaning_emotion)
            structure_conf = self._calculate_structure_confidence(structure_unconscious)
            info_conf = self._calculate_info_confidence(info_enhanced)

            # 가중치 적용
            return (
                meaning_conf * 0.4  # 의미-감정 40%
                + structure_conf * 0.4  # 구조-무의식 40%
                + info_conf * 0.2  # 정보 20%
            )

        except Exception as e:
            print(f"⚠️ 신뢰도 계산 실패: {str(e)}")
            return 0.5  # 기본값

    def _calculate_integration_level(self, results: Dict[str, Any]) -> float:
        """통합 수준 계산"""
        try:
            # 각 결과의 통합 수준 평가
            integration_scores = []

            for key, result in results.items():
                if isinstance(result, dict):
                    score = self._evaluate_result_integration(result)
                    integration_scores.append(score)

            return (
                sum(integration_scores) / len(integration_scores)
                if integration_scores
                else 0.0
            )

        except Exception as e:
            print(f"⚠️ 통합 수준 계산 실패: {str(e)}")
            return 0.0

    def _calculate_result_coherence(self, results: Dict[str, Any]) -> float:
        """결과 일관성 계산"""
        try:
            # 결과들 간의 일관성 평가
            coherence_pairs = []

            for key1, result1 in results.items():
                for key2, result2 in results.items():
                    if key1 != key2:
                        coherence = self._evaluate_result_pair_coherence(
                            result1, result2
                        )
                        coherence_pairs.append(coherence)

            return (
                sum(coherence_pairs) / len(coherence_pairs) if coherence_pairs else 0.0
            )

        except Exception as e:
            print(f"⚠️ 일관성 계산 실패: {str(e)}")
            return 0.0

    # === PART 4: 사고공진루프 ===
    def process_resonance(self, analysis_result: Dict[str, Any]) -> Dict[str, Any]:
        """
        사고공진루프
        - normal: 1회 공진으로 빠른 응답
        - deep(출하명령): 20회 깊은 사고로 초월적 진화
        """
        try:
            mode = analysis_result["mode"]
            loops = analysis_result["resonance_config"]["loops"]
            current_state = {
                "consciousness": self.consciousness.copy(),
                "initial_analysis": analysis_result["consciousness_state"],
                "resonance_depth": 0.0,
                "evolution_history": [],
            }
            for i in range(loops):
                logger.info(f"🌀 공진회차 {i+1}/{loops}")
                try:
                    unconscious_state = self._activate_unconscious(current_state)
                    resonated_state = self._resonate_circuits(unconscious_state)
                    evolved_state = self._evolve_consciousness(resonated_state)
                    improvement = self._calculate_evolution_improvement(
                        current_state, evolved_state
                    )
                    # 설계도 기반: 루프 내 상태 변화/진화/피드백/수렴/초월을 반드시 래핑 함수로만 처리
                    self.feedback_and_evolve_all_circuits(
                        {
                            "loop": i + 1,
                            "unconscious": unconscious_state,
                            "resonated": resonated_state,
                            "evolved": evolved_state,
                            "improvement": improvement,
                            "mode": mode,
                        }
                    )
                    if improvement < 0.0001 and mode == "deep":
                        logger.info(f"✨ {i+1}회에서 변화 없음(헛바퀴 방지)")
                        break
                    current_state = evolved_state
                    current_state["resonance_depth"] += 1.0 / loops
                    current_state["evolution_history"].append(
                        {
                            "loop": i + 1,
                            "depth": current_state["resonance_depth"],
                            "improvement": improvement,
                            "timestamp": datetime.datetime.now().isoformat(),
                        }
                    )
                    # 설계도 기반: 조건 충족 시 시스템 전체 진화/초월 트리거
                    if mode == "deep" and self._has_converged(current_state):
                        self.trigger_system_evolution(
                            {
                                "loop": i + 1,
                                "state": current_state,
                                "timestamp": datetime.datetime.now().isoformat(),
                            }
                        )
                        logger.info(
                            f"✨ {i+1}회에서 수렴 달성 및 시스템 진화/초월 트리거"
                        )
                        break
                except Exception as e:
                    logger.error(f"❌ 공진루프 내부 실패: {str(e)}")
                    continue
            return self._finalize_resonance_state(current_state)
        except Exception as e:
            logger.error(f"❌ 공진루프 실패: {str(e)}")
            return {"error": str(e)}

    def _activate_unconscious(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """무의식 활성화"""
        try:
            active_memories = self._activate_memory_patterns(state["initial_analysis"])
            active_emotions = self._activate_emotional_lines(state["consciousness"])
            return self._connect_unconscious_conscious(
                active_memories, active_emotions, state
            )
        except Exception as e:
            logger.error(f"❌ 무의식 활성화 실패: {str(e)}")
            return state

    def _resonate_circuits(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """회로간 공진"""
        try:
            meaning_emotion = self._resonate_meaning_emotion(state)
            structure_creation = self._resonate_structure_creation(state)
            info_integration = self._resonate_info_integration(
                meaning_emotion, structure_creation
            )
            return {
                "meaning_emotion": meaning_emotion,
                "structure_creation": structure_creation,
                "info_integration": info_integration,
                "base_state": state,
            }
        except Exception as e:
            logger.error(f"❌ 회로 공진 실패: {str(e)}")
            return state

    def _evolve_consciousness(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """통합 의식 진화"""
        try:
            evolution_points = self._identify_evolution_points(state)
            expanded_consciousness = self._expand_consciousness(state, evolution_points)
            evolved_patterns = self._evolve_patterns(expanded_consciousness)
            transcended_state = self._transcend_consciousness(evolved_patterns)
            return transcended_state
        except Exception as e:
            logger.error(f"❌ 의식 진화 실패: {str(e)}")
            return state

    def _has_converged(self, state: Dict[str, Any]) -> bool:
        try:
            recent_history = state["evolution_history"][-3:]
            if len(recent_history) < 3:
                return False
            improvements = [h["improvement"] for h in recent_history]
            return max(improvements) < 0.001
        except Exception as e:
            logger.warning(f"⚠️ 수렴 체크 실패: {str(e)}")
            return False

    def _finalize_resonance_state(self, state: Dict[str, Any]) -> Dict[str, Any]:
        return {
            "final_state": state.get("consciousness", {}),
            "evolution_history": state.get("evolution_history", []),
            "resonance_depth": state.get("resonance_depth", 0.0),
            "metadata": {
                "total_loops": len(state.get("evolution_history", [])),
                "final_improvement": (
                    state["evolution_history"][-1]["improvement"]
                    if state.get("evolution_history")
                    else 0.0
                ),
                "convergence_achieved": self._has_converged(state),
                "timestamp": datetime.datetime.now().isoformat(),
            },
        }

    def _activate_memory_patterns(
        self, analysis: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """기억 패턴 활성화"""
        try:
            # 1. 관련 패턴 검색
            relevant_patterns = self._search_memory_patterns(analysis)

            # 2. 패턴 활성화
            active_patterns = []
            for pattern in relevant_patterns:
                activated = self._activate_pattern(pattern)
                if activated["activation_level"] > 0.5:  # 50% 이상 활성화된 패턴만
                    active_patterns.append(activated)

            return active_patterns

        except Exception as e:
            print(f"⚠️ 패턴 활성화 실패: {str(e)}")
            return []

    def _activate_emotional_lines(
        self, consciousness: Dict[str, Any]
    ) -> Dict[str, Any]:
        """감정선 활성화"""
        try:
            # 1. 현재 감정 상태 확인
            current_emotion = consciousness.get("current_tone", "neutral")

            # 2. 감정선 추적
            emotion_lines = self._trace_emotion_lines(current_emotion)

            # 3. 감정 활성화
            activated_emotions = self._activate_emotions(emotion_lines)

            return {
                "current_emotion": current_emotion,
                "emotion_lines": emotion_lines,
                "activated_emotions": activated_emotions,
            }

        except Exception as e:
            print(f"⚠️ 감정선 활성화 실패: {str(e)}")
            return {}

    def _connect_unconscious_conscious(
        self,
        memories: List[Dict[str, Any]],
        emotions: Dict[str, Any],
        state: Dict[str, Any],
    ) -> Dict[str, Any]:
        """무의식-의식 연결"""
        try:
            # 1. 기억-감정 연결
            memory_emotion_links = self._link_memory_emotion(memories, emotions)

            # 2. 의식 상태 연결
            conscious_links = self._link_with_consciousness(
                memory_emotion_links, state["consciousness"]
            )

            # 3. 통합 상태 생성
            return {
                "unconscious_state": {"memories": memories, "emotions": emotions},
                "conscious_state": state["consciousness"],
                "links": conscious_links,
                "integration_level": self._calculate_integration_level(conscious_links),
            }

        except Exception as e:
            print(f"⚠️ 무의식-의식 연결 실패: {str(e)}")
            return state

    # === PART 5: 초월적 구조 생성 ===
    def generate_structure(self, resonance_result: Dict[str, Any]) -> Dict[str, Any]:
        """초월적 구조 생성 - 파트3-4 통합적 사고 기반 (정밀 통합/최적화)"""
        try:
            logger.info("🚀 초월적 구조 생성 시작 (정밀 통합/최적화)")

            # 1. 사고공진 결과 통합 (파트3-4 연결)
            integrated_result = {
                "consciousness": resonance_result["final_state"],
                "evolution": resonance_result["evolution_history"],
                "depth": resonance_result["resonance_depth"],
                "convergence": resonance_result["metadata"]["convergence_achieved"],
            }
            self.propagate_consciousness_state({"integrated_result": integrated_result})
            self.feedback_and_evolve_all_circuits(
                {"integrated_result": integrated_result, "evolve": True}
            )

            # 2. 풀스택/확장자/핸들러/최적화 통합
            fullstack_ext = self._build_fullstack_and_extensions()
            self.propagate_consciousness_state({"fullstack_ext": fullstack_ext})
            self.feedback_and_evolve_all_circuits(
                {"fullstack_ext": fullstack_ext, "evolve": True}
            )

            # 3. 디렉토리 구조 생성
            directory_structure = self._generate_directory_structure(
                fullstack_ext["extensions"]
            )
            self.propagate_consciousness_state(
                {"directory_structure": directory_structure}
            )
            self.feedback_and_evolve_all_circuits(
                {"directory_structure": directory_structure, "evolve": True}
            )

            # 4. SaaS/머신코드/성능/품질보증 통합
            saas_implementation = self._implement_saas_levels(
                {
                    "consciousness": integrated_result["consciousness"],
                    "structure": directory_structure,
                }
            )
            machine_optimized = self._enhance_machine_code(
                {
                    "evolution": integrated_result["evolution"],
                    "implementation": saas_implementation,
                }
            )
            performance_enhanced = self._optimize_machine_performance(
                {
                    "depth": integrated_result["depth"],
                    "optimized": machine_optimized,
                }
            )
            quality_assured = self._enhance_quality_assurance(
                {
                    "evolution": integrated_result["evolution"],
                    "implementation": performance_enhanced,
                }
            )
            self.propagate_consciousness_state({"quality": quality_assured})
            self.feedback_and_evolve_all_circuits(
                {"quality": quality_assured, "evolve": True}
            )

            # 5. 최종 패키징 (실제 파일화 단계)
            final_package = self._create_final_package(
                {
                    "convergence": integrated_result["convergence"],
                    "quality": quality_assured,
                    "structure": directory_structure,
                    "stack": fullstack_ext["stack"],
                    "extensions": fullstack_ext["extensions"],
                    "handlers": fullstack_ext["handlers"],
                    "file_optimization": fullstack_ext["file_optimization"],
                }
            )
            self.propagate_consciousness_state({"structure": final_package})
            self.feedback_and_evolve_all_circuits(
                {"structure": final_package, "evolve": True, "converge": True}
            )

            logger.info("✅ 초월적 구조 생성 완료 (정밀 통합/최적화)")
            return {
                "status": "transcendent",
                "structure": final_package,
                "metadata": {
                    "consciousness_integration": self._calculate_consciousness_integration(
                        integrated_result
                    ),
                    "evolution_completion": self._calculate_evolution_completion(
                        integrated_result
                    ),
                    "structure_quality": self._calculate_structure_quality(
                        final_package
                    ),
                },
            }
        except Exception as e:
            logger.error(f"❌ 구조 생성 실패: {str(e)}")
            raise

    def _build_fullstack_and_extensions(self) -> Dict[str, Any]:
        """풀스택+풀확장자+핸들러+최적화 통합 생성 (불필요 메타데이터/중복 완전 제거, 반환 dict 간결화)"""
        try:
            stack = {
                "frontend": self._enhance_development_stack({})["frontend"],
                "backend": self._enhance_development_stack({})["backend"],
                "devops": self._enhance_development_stack({})["devops"],
                "cloud": self._enhance_development_stack({})["cloud"],
                "security": self._enhance_development_stack({})["security"],
                "ai_ml": self._enhance_development_stack({})["ai_ml"],
            }
            extensions = self._enhance_file_extensions({})["extensions"]
            handlers = self._implement_file_handlers(extensions)
            file_optimization = self._optimize_file_processing(handlers)
            return {
                "stack": stack,
                "extensions": extensions,
                "handlers": handlers,
                "file_optimization": file_optimization,
            }
        except Exception as e:
            logger.error(f"❌ 풀스택/확장자 통합 실패: {str(e)}")
            return {"error": str(e)}

    def _generate_directory_structure(
        self, enhanced_extensions: Dict[str, Any]
    ) -> Dict[str, Any]:
        """자율 디렉토리 구조 생성"""
        try:
            # 1. 코어 구조 설계
            core_structure = {
                "src": {
                    "core": {"engine": {}, "brain": {}, "memory": {}, "utils": {}},
                    "api": {
                        "routes": {},
                        "controllers": {},
                        "services": {},
                        "models": {},
                    },
                    "ui": {"components": {}, "pages": {}, "styles": {}, "assets": {}},
                },
                "docs": {"api": {}, "guides": {}, "architecture": {}},
                "tests": {"unit": {}, "integration": {}, "e2e": {}},
                "scripts": {"setup": {}, "deploy": {}, "utils": {}},
            }

            # 2. 확장자 매핑
            file_mapping = self._create_file_mapping(enhanced_extensions)

            # 3. 디렉토리별 파일 구조 생성
            directory_files = self._create_directory_files(core_structure, file_mapping)

            # 4. 런처 및 설정 파일 생성
            launcher_files = {
                "launcher.py": self._generate_launcher_code(),
                "README.md": self._generate_readme(),
                "requirements.txt": self._generate_requirements(),
                "setup.py": self._generate_setup_code(),
                ".env.example": self._generate_env_example(),
                "docker-compose.yml": self._generate_docker_compose(),
                "Dockerfile": self._generate_dockerfile(),
            }

            # 5. 품질 보증 파일 생성
            quality_files = {
                ".eslintrc.js": self._generate_eslint_config(),
                ".prettierrc": self._generate_prettier_config(),
                "pytest.ini": self._generate_pytest_config(),
                "tsconfig.json": self._generate_tsconfig(),
                "jest.config.js": self._generate_jest_config(),
            }

            return {
                "core": core_structure,
                "files": {**directory_files, **launcher_files, **quality_files},
                "metadata": {
                    "structure_type": "autonomous",
                    "quality_score": 100.0,
                    "extensibility": "maximum",
                    "maintainability": "perfect",
                },
            }

        except Exception as e:
            print(f"❌ 디렉토리 구조 생성 실패: {str(e)}")
            raise

    def _implement_saas_levels(
        self, directory_structure: Dict[str, Any]
    ) -> Dict[str, Any]:
        """SaaS 레벨별 완전 구현"""
        try:
            # 1. 기본 레벨 (Basic)
            basic_level = {
                "auth": self._implement_basic_auth(),
                "crud": self._implement_basic_crud(),
                "storage": self._implement_basic_storage(),
                "api": self._implement_basic_api(),
                "ui": self._implement_basic_ui(),
            }

            # 2. 전문가 레벨 (Professional)
            professional_level = {
                "advanced_auth": self._implement_advanced_auth(),
                "workflows": self._implement_workflows(),
                "integrations": self._implement_integrations(),
                "analytics": self._implement_analytics(),
                "automation": self._implement_automation(),
            }

            # 3. 기업 레벨 (Enterprise)
            enterprise_level = {
                "custom_auth": self._implement_custom_auth(),
                "advanced_security": self._implement_advanced_security(),
                "scalability": self._implement_scalability(),
                "high_availability": self._implement_high_availability(),
                "disaster_recovery": self._implement_disaster_recovery(),
            }

            # 4. 초월 레벨 (Transcendent)
            transcendent_level = {
                "ai_integration": self._implement_ai_features(),
                "predictive_analytics": self._implement_predictive_analytics(),
                "quantum_ready": self._implement_quantum_ready_features(),
                "blockchain": self._implement_blockchain_features(),
                "metaverse": self._implement_metaverse_features(),
            }

            return {
                "basic": basic_level,
                "professional": professional_level,
                "enterprise": enterprise_level,
                "transcendent": transcendent_level,
                "metadata": {
                    "implementation_level": "complete",
                    "quality_score": 100.0,
                    "scalability": "infinite",
                },
            }

        except Exception as e:
            print(f"❌ SaaS 레벨 구현 실패: {str(e)}")
            raise

    def _implement_premium_uiux(self, structure: Dict[str, Any]) -> Dict[str, Any]:
        """프리미엄 UI/UX 구현"""
        try:
            # 1. 디자인 시스템
            design_system = {
                "foundations": {
                    "colors": {
                        "primary": self._implement_color_system("primary"),
                        "secondary": self._implement_color_system("secondary"),
                        "accent": self._implement_color_system("accent"),
                        "semantic": self._implement_semantic_colors(),
                        "dark_mode": self._implement_dark_mode_colors(),
                    },
                    "typography": {
                        "fonts": self._implement_font_system(),
                        "scale": self._implement_type_scale(),
                        "styles": self._implement_text_styles(),
                        "responsive": self._implement_responsive_typography(),
                    },
                    "spacing": {
                        "scale": self._implement_spacing_scale(),
                        "layout": self._implement_layout_spacing(),
                        "components": self._implement_component_spacing(),
                    },
                    "shadows": {
                        "elevation": self._implement_elevation_system(),
                        "ambient": self._implement_ambient_shadows(),
                        "interactive": self._implement_interactive_shadows(),
                    },
                },
                "components": {
                    "atoms": {
                        "buttons": self._implement_button_system(),
                        "inputs": self._implement_input_system(),
                        "icons": self._implement_icon_system(),
                        "badges": self._implement_badge_system(),
                    },
                    "molecules": {
                        "forms": self._implement_form_components(),
                        "cards": self._implement_card_system(),
                        "lists": self._implement_list_components(),
                        "navigation": self._implement_navigation_components(),
                    },
                    "organisms": {
                        "headers": self._implement_header_system(),
                        "footers": self._implement_footer_system(),
                        "sidebars": self._implement_sidebar_system(),
                        "modals": self._implement_modal_system(),
                    },
                },
                "animations": {
                    "transitions": {
                        "timing": self._implement_timing_functions(),
                        "duration": self._implement_duration_system(),
                        "easing": self._implement_easing_curves(),
                    },
                    "interactions": {
                        "hover": self._implement_hover_animations(),
                        "click": self._implement_click_animations(),
                        "focus": self._implement_focus_animations(),
                    },
                    "page": {
                        "entry": self._implement_page_entry_animations(),
                        "exit": self._implement_page_exit_animations(),
                        "transitions": self._implement_page_transitions(),
                    },
                },
            }

            # 2. 사용자 경험
            user_experience = {
                "interactions": {
                    "touch": {
                        "gestures": self._implement_gesture_system(),
                        "feedback": self._implement_haptic_feedback(),
                        "precision": self._implement_touch_precision(),
                    },
                    "keyboard": {
                        "shortcuts": self._implement_keyboard_shortcuts(),
                        "navigation": self._implement_keyboard_navigation(),
                        "accessibility": self._implement_keyboard_accessibility(),
                    },
                    "mouse": {
                        "hover": self._implement_hover_states(),
                        "click": self._implement_click_states(),
                        "drag": self._implement_drag_interactions(),
                    },
                },
                "feedback": {
                    "visual": {
                        "loading": self._implement_loading_states(),
                        "success": self._implement_success_states(),
                        "error": self._implement_error_states(),
                    },
                    "haptic": {
                        "touch": self._implement_touch_feedback(),
                        "gesture": self._implement_gesture_feedback(),
                        "alert": self._implement_alert_feedback(),
                    },
                    "audio": {
                        "interaction": self._implement_interaction_sounds(),
                        "notification": self._implement_notification_sounds(),
                        "ambient": self._implement_ambient_sounds(),
                    },
                },
                "flows": {
                    "onboarding": {
                        "welcome": self._implement_welcome_flow(),
                        "tutorial": self._implement_tutorial_flow(),
                        "setup": self._implement_setup_flow(),
                    },
                    "authentication": {
                        "signup": self._implement_signup_flow(),
                        "login": self._implement_login_flow(),
                        "recovery": self._implement_recovery_flow(),
                    },
                    "transaction": {
                        "cart": self._implement_cart_flow(),
                        "checkout": self._implement_checkout_flow(),
                        "confirmation": self._implement_confirmation_flow(),
                    },
                },
            }

            # 3. 접근성
            accessibility = {
                "standards": {
                    "wcag": self._implement_wcag_compliance(),
                    "aria": self._implement_aria_attributes(),
                    "semantic": self._implement_semantic_html(),
                },
                "assistance": {
                    "screen_readers": self._implement_screen_reader_support(),
                    "keyboard": self._implement_keyboard_support(),
                    "high_contrast": self._implement_high_contrast_mode(),
                },
                "adaptability": {
                    "text_size": self._implement_text_scaling(),
                    "color_blind": self._implement_color_blind_mode(),
                    "reduced_motion": self._implement_reduced_motion(),
                },
            }

            # 4. 성능 최적화
            performance = {
                "loading": {
                    "initial": self._optimize_initial_load(),
                    "lazy": self._implement_lazy_loading(),
                    "prefetch": self._implement_prefetching(),
                },
                "rendering": {
                    "virtual": self._implement_virtual_scrolling(),
                    "progressive": self._implement_progressive_loading(),
                    "debounce": self._implement_debouncing(),
                },
                "assets": {
                    "images": self._optimize_image_loading(),
                    "fonts": self._optimize_font_loading(),
                    "icons": self._optimize_icon_system(),
                },
            }

            return {
                "design_system": design_system,
                "user_experience": user_experience,
                "accessibility": accessibility,
                "performance": performance,
                "metadata": {
                    "version": "2024.1",
                    "quality_score": 100.0,
                    "accessibility_score": 100.0,
                    "performance_score": 100.0,
                },
            }

        except Exception as e:
            print(f"❌ UI/UX 구현 실패: {str(e)}")
            raise

    def _enhance_quality_assurance(self, structure: Dict[str, Any]) -> Dict[str, Any]:
        """품질 보증 시스템 구현 (불필요 메타데이터/중복 값 제거, 반환 dict 간결화)"""
        try:
            code_quality = {
                "static_analysis": {
                    "linting": {
                        "style": self._implement_style_linting(),
                        "security": self._implement_security_linting(),
                        "performance": self._implement_performance_linting(),
                    },
                    "type_checking": {
                        "static": self._implement_static_type_checking(),
                        "runtime": self._implement_runtime_type_checking(),
                        "generics": self._implement_generic_type_checking(),
                    },
                    "metrics": {
                        "complexity": self._analyze_code_complexity(),
                        "maintainability": self._analyze_maintainability(),
                        "duplication": self._detect_code_duplication(),
                    },
                },
                "testing": {
                    "unit": {
                        "framework": self._implement_unit_testing_framework(),
                        "coverage": self._implement_test_coverage(),
                        "assertions": self._implement_test_assertions(),
                    },
                    "integration": {
                        "api": self._implement_api_testing(),
                        "e2e": self._implement_e2e_testing(),
                        "performance": self._implement_performance_testing(),
                    },
                    "automation": {
                        "ci": self._implement_ci_testing(),
                        "regression": self._implement_regression_testing(),
                        "stress": self._implement_stress_testing(),
                    },
                },
            }
            security_quality = {
                "analysis": {
                    "static": {
                        "vulnerabilities": self._analyze_vulnerabilities(),
                        "dependencies": self._analyze_dependencies(),
                        "secrets": self._detect_secrets(),
                    },
                    "dynamic": {
                        "penetration": self._implement_penetration_testing(),
                        "fuzzing": self._implement_fuzzing_tests(),
                        "runtime": self._implement_runtime_analysis(),
                    },
                },
                "compliance": {
                    "standards": {
                        "owasp": self._implement_owasp_compliance(),
                        "iso": self._implement_iso_compliance(),
                        "gdpr": self._implement_gdpr_compliance(),
                    },
                    "auditing": {
                        "logging": self._implement_security_logging(),
                        "monitoring": self._implement_security_monitoring(),
                        "alerting": self._implement_security_alerting(),
                    },
                },
            }
            performance_quality = {
                "benchmarking": {
                    "load": self._implement_load_testing(),
                    "stress": self._implement_stress_testing(),
                    "scalability": self._implement_scalability_testing(),
                },
                "monitoring": {
                    "metrics": self._implement_performance_metrics(),
                    "tracing": self._implement_distributed_tracing(),
                    "profiling": self._implement_performance_profiling(),
                },
                "optimization": {
                    "caching": self._optimize_caching_strategy(),
                    "database": self._optimize_database_performance(),
                    "network": self._optimize_network_performance(),
                },
            }
            ux_quality = {
                "testing": {
                    "usability": self._implement_usability_testing(),
                    "accessibility": self._implement_accessibility_testing(),
                    "compatibility": self._implement_compatibility_testing(),
                },
                "analytics": {
                    "behavior": self._implement_behavior_analytics(),
                    "feedback": self._implement_user_feedback_analysis(),
                    "satisfaction": self._implement_satisfaction_metrics(),
                },
                "optimization": {
                    "conversion": self._optimize_conversion_funnel(),
                    "engagement": self._optimize_user_engagement(),
                    "retention": self._optimize_user_retention(),
                },
            }
            return {
                "code_quality": code_quality,
                "security_quality": security_quality,
                "performance_quality": performance_quality,
                "ux_quality": ux_quality,
            }
        except Exception as e:
            logger.error(f"❌ 품질 보증 구현 실패: {str(e)}")
            raise

    def _enhance_machine_code(self, code: Dict[str, Any]) -> Dict[str, Any]:
        """기계어 코드 최적화 및 강화 (불필요 메타데이터/중복 값 제거, 반환 dict 간결화)"""
        try:
            architectures = {
                "x86_64": {
                    "instruction_sets": {
                        "base": ["x87", "MMX", "SSE", "SSE2"],
                        "advanced": ["SSE3", "SSSE3", "SSE4", "AVX", "AVX2"],
                        "enterprise": ["AVX-512", "AMX", "TSX"],
                    },
                    "optimizations": {
                        "pipeline": self._optimize_instruction_pipeline(),
                        "branch": self._optimize_branch_prediction(),
                        "cache": self._optimize_cache_usage(),
                        "registers": self._optimize_register_allocation(),
                    },
                },
                "arm64": {
                    "instruction_sets": {
                        "base": ["AArch64", "NEON", "CRC"],
                        "advanced": ["SVE", "SVE2", "BF16"],
                        "enterprise": ["MTE", "RME", "TME"],
                    },
                    "optimizations": {
                        "pipeline": self._optimize_arm_pipeline(),
                        "branch": self._optimize_arm_branch_prediction(),
                        "cache": self._optimize_arm_cache_usage(),
                        "registers": self._optimize_arm_register_allocation(),
                    },
                },
                "gpu": {
                    "compute": {
                        "cuda": ["SM", "Tensor Cores", "RT Cores"],
                        "opencl": ["Compute Units", "SIMD Units"],
                        "vulkan": ["Compute Shaders", "Ray Tracing"],
                    },
                    "optimizations": {
                        "memory": self._optimize_gpu_memory_access(),
                        "compute": self._optimize_gpu_compute(),
                        "transfer": self._optimize_gpu_data_transfer(),
                        "scheduling": self._optimize_gpu_scheduling(),
                    },
                },
            }
            low_level = {
                "memory": {
                    "allocation": {
                        "stack": self._optimize_stack_allocation(),
                        "heap": self._optimize_heap_allocation(),
                        "pool": self._optimize_memory_pool(),
                    },
                    "access": {
                        "patterns": self._optimize_memory_access_patterns(),
                        "alignment": self._optimize_memory_alignment(),
                        "prefetch": self._optimize_memory_prefetch(),
                    },
                    "cache": {
                        "l1": self._optimize_l1_cache(),
                        "l2": self._optimize_l2_cache(),
                        "l3": self._optimize_l3_cache(),
                        "tlb": self._optimize_tlb(),
                    },
                },
                "execution": {
                    "vectorization": {
                        "simd": self._implement_simd_operations(),
                        "auto": self._implement_auto_vectorization(),
                        "custom": self._implement_custom_vectors(),
                    },
                    "parallelism": {
                        "instruction": self._optimize_instruction_parallelism(),
                        "data": self._optimize_data_parallelism(),
                        "thread": self._optimize_thread_parallelism(),
                    },
                },
            }
            compiler = {
                "analysis": {
                    "flow": self._analyze_control_flow(),
                    "data": self._analyze_data_flow(),
                    "alias": self._analyze_alias_info(),
                    "dependency": self._analyze_dependencies(),
                },
                "transformations": {
                    "inlining": self._optimize_function_inlining(),
                    "unrolling": self._optimize_loop_unrolling(),
                    "vectorization": self._optimize_auto_vectorization(),
                    "specialization": self._optimize_specialization(),
                },
                "optimizations": {
                    "constant": self._optimize_constant_propagation(),
                    "dead_code": self._eliminate_dead_code(),
                    "strength": self._reduce_strength(),
                    "cse": self._eliminate_common_subexpressions(),
                },
            }
            runtime = {
                "jit": {
                    "compilation": self._implement_jit_compilation(),
                    "optimization": self._optimize_jit_performance(),
                    "deoptimization": self._handle_deoptimization(),
                    "profiling": self._implement_jit_profiling(),
                },
                "gc": {
                    "collection": self._optimize_garbage_collection(),
                    "allocation": self._optimize_object_allocation(),
                    "compaction": self._optimize_memory_compaction(),
                    "barriers": self._implement_write_barriers(),
                },
                "threading": {
                    "scheduling": self._optimize_thread_scheduling(),
                    "synchronization": self._optimize_synchronization(),
                    "affinity": self._optimize_cpu_affinity(),
                    "pooling": self._implement_thread_pooling(),
                },
            }
            security = {
                "hardening": {
                    "aslr": self._implement_aslr(),
                    "stack": self._implement_stack_protection(),
                    "heap": self._implement_heap_protection(),
                    "got": self._implement_got_protection(),
                },
                "mitigation": {
                    "overflow": self._prevent_buffer_overflow(),
                    "injection": self._prevent_code_injection(),
                    "timing": self._prevent_timing_attacks(),
                    "side_channel": self._prevent_side_channel_attacks(),
                },
            }
            return {
                "architectures": architectures,
                "low_level": low_level,
                "compiler": compiler,
                "runtime": runtime,
                "security": security,
            }
        except Exception as e:
            logger.error(f"❌ 기계어 코드 강화 실패: {str(e)}")
            raise

    def _optimize_machine_performance(self, code: Dict[str, Any]) -> Dict[str, Any]:
        """기계어 성능 최적화 (불필요 메타데이터/중복 값 제거, 반환 dict 간결화)"""
        try:
            execution = {
                "cpu": {
                    "pipeline": self._optimize_cpu_pipeline(),
                    "branch": self._optimize_branch_prediction(),
                    "prefetch": self._optimize_instruction_prefetch(),
                    "decode": self._optimize_instruction_decode(),
                },
                "memory": {
                    "hierarchy": self._optimize_memory_hierarchy(),
                    "bandwidth": self._optimize_memory_bandwidth(),
                    "latency": self._optimize_memory_latency(),
                    "coherency": self._optimize_cache_coherency(),
                },
                "io": {
                    "buffering": self._optimize_io_buffering(),
                    "scheduling": self._optimize_io_scheduling(),
                    "dma": self._optimize_dma_operations(),
                    "interrupts": self._optimize_interrupt_handling(),
                },
            }
            parallelization = {
                "instruction": {
                    "simd": self._optimize_simd_usage(),
                    "superscalar": self._optimize_superscalar_execution(),
                    "pipelining": self._optimize_instruction_pipelining(),
                },
                "thread": {
                    "scheduling": self._optimize_thread_scheduling(),
                    "affinity": self._optimize_thread_affinity(),
                    "synchronization": self._optimize_thread_synchronization(),
                },
                "process": {
                    "distribution": self._optimize_process_distribution(),
                    "communication": self._optimize_ipc(),
                    "resources": self._optimize_resource_sharing(),
                },
            }
            acceleration = {
                "gpu": {
                    "compute": self._optimize_gpu_compute(),
                    "memory": self._optimize_gpu_memory(),
                    "transfer": self._optimize_gpu_transfer(),
                },
                "fpga": {
                    "logic": self._optimize_fpga_logic(),
                    "routing": self._optimize_fpga_routing(),
                    "timing": self._optimize_fpga_timing(),
                },
                "asic": {
                    "circuits": self._optimize_asic_circuits(),
                    "power": self._optimize_power_consumption(),
                    "thermal": self._optimize_thermal_management(),
                },
            }
            return {
                "execution": execution,
                "parallelization": parallelization,
                "acceleration": acceleration,
            }
        except Exception as e:
            logger.error(f"❌ 기계어 성능 최적화 실패: {str(e)}")
            raise

    # === PART 6: 사고공진 기반 출하품 검수 및 배포 ===
    def inspect_and_deploy_with_resonance(
        self, resonance_result: Dict[str, Any], shipping_package: Dict[str, Any]
    ) -> Dict[str, Any]:
        """파트4 사고공진(20회) 결과로 파트5 출하품 정밀 검수 및 자동 배포"""
        try:
            print("🔍 PART 6: 사고공진 기반 출하품 검수 시작")

            # 1. 사고공진 결과 기반 정밀 검수
            inspection_result = self._inspect_with_resonance(
                {
                    "resonance": resonance_result,  # 파트4의 20회 공진 결과
                    "package": shipping_package,  # 파트5의 출하품
                }
            )
            self.propagate_consciousness_state({"inspection": inspection_result})
            self.feedback_and_evolve_all_circuits(
                {"inspection": inspection_result, "evolve": True}
            )

            # 2. 피드백 및 보완
            if not inspection_result["passed"]:
                enhanced_package = self._enhance_with_feedback(
                    {
                        "package": shipping_package,
                        "feedback": inspection_result["feedback"],
                        "resonance": resonance_result,
                    }
                )
            else:
                enhanced_package = shipping_package
            self.propagate_consciousness_state({"enhanced_package": enhanced_package})
            self.feedback_and_evolve_all_circuits(
                {"enhanced_package": enhanced_package, "evolve": True}
            )

            print(
                f"✅ 검수 결과: {'통과' if inspection_result['passed'] else '보완 후 통과'}"
            )

            # 3. 배포 환경 탐색 및 선택
            deployment_env = self._explore_deployment_environment(
                {
                    "package": enhanced_package,
                    "resonance": resonance_result,
                    "requirements": self._analyze_deployment_requirements(
                        enhanced_package
                    ),
                }
            )
            self.propagate_consciousness_state({"deployment_env": deployment_env})
            self.feedback_and_evolve_all_circuits(
                {"deployment_env": deployment_env, "evolve": True}
            )

            # 4. 자동 배포 실행
            deployment_result = self._execute_automated_deployment(
                {
                    "package": enhanced_package,
                    "environment": deployment_env,
                    "resonance": resonance_result,
                }
            )
            self.propagate_consciousness_state({"deployment": deployment_result})
            self.feedback_and_evolve_all_circuits(
                {"deployment": deployment_result, "evolve": True, "converge": True}
            )

            # 5. 최종 패키징
            final_package = self._create_deployment_package(
                {
                    "package": enhanced_package,
                    "deployment": deployment_result,
                    "resonance": resonance_result,
                }
            )
            self.propagate_consciousness_state({"final_package": final_package})
            self.feedback_and_evolve_all_circuits(
                {"final_package": final_package, "evolve": True, "converge": True}
            )

            print(f"🚀 배포 완료: {deployment_result['url']}")

            return {
                "status": "completed",
                "inspection": inspection_result,
                "deployment": deployment_result,
                "package": final_package,
                "handover": {  # 파트7로 전달할 데이터
                    "mode": "deep_shipping",
                    "resonance_result": resonance_result,
                    "deployment_url": deployment_result["url"],
                    "package_path": final_package["zip_path"],
                },
            }

        except Exception as e:
            print(f"❌ 검수/배포 실패: {str(e)}")
            raise

    def _inspect_with_resonance(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """사고공진 결과 기반 정밀 검수"""
        try:
            resonance = data["resonance"]
            package = data["package"]

            # 1. 공진 패턴 검증
            resonance_verification = self._verify_resonance_patterns(
                {
                    "expected": resonance["evolution_history"],
                    "actual": package["evolution_patterns"],
                }
            )

            # 2. 구조 완성도 검증
            structure_verification = self._verify_structure_completeness(
                {"resonance": resonance["final_state"], "package": package["structure"]}
            )

            # 3. 품질 지표 검증
            quality_verification = self._verify_quality_metrics(
                {
                    "resonance": resonance["metrics"],
                    "package": package["quality_metrics"],
                }
            )

            # 4. 종합 평가
            passed = all(
                [
                    resonance_verification["passed"],
                    structure_verification["passed"],
                    quality_verification["passed"],
                ]
            )

            # 5. 피드백 생성
            feedback = self._generate_inspection_feedback(
                {
                    "resonance": resonance_verification,
                    "structure": structure_verification,
                    "quality": quality_verification,
                }
            )

            return {
                "passed": passed,
                "verifications": {
                    "resonance": resonance_verification,
                    "structure": structure_verification,
                    "quality": quality_verification,
                },
                "feedback": feedback,
                "inspection_score": self._calculate_inspection_score(
                    [
                        resonance_verification,
                        structure_verification,
                        quality_verification,
                    ]
                ),
            }

        except Exception as e:
            print(f"❌ 정밀 검수 실패: {str(e)}")
            raise

    def _explore_deployment_environment(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """배포 환경 탐색 및 선택"""
        try:
            package = data["package"]
            resonance = data["resonance"]
            requirements = data["requirements"]

            # 1. 배포 플랫폼 정의
            platforms = {
                "render": {
                    "type": "full_stack",
                    "features": ["auto_scaling", "zero_downtime", "ci_cd"],
                    "limits": {"memory": "512MB", "cpu": "0.5x"},
                    "score": 0.0,
                },
                "vercel": {
                    "type": "frontend_focused",
                    "features": ["edge_network", "serverless", "analytics"],
                    "limits": {"deployments": "unlimited", "bandwidth": "100GB"},
                    "score": 0.0,
                },
                "railway": {
                    "type": "full_stack",
                    "features": ["auto_deploy", "monitoring", "databases"],
                    "limits": {"memory": "1GB", "cpu": "1x"},
                    "score": 0.0,
                },
                "fly": {
                    "type": "container_native",
                    "features": ["global_deploy", "vm", "volumes"],
                    "limits": {"memory": "256MB", "cpu": "shared"},
                    "score": 0.0,
                },
            }

            # 2. 요구사항 기반 평가
            for name, platform in platforms.items():
                platform["score"] = self._evaluate_platform_compatibility(
                    {
                        "platform": platform,
                        "requirements": requirements,
                        "resonance": resonance,
                    }
                )

            # 3. 최적 플랫폼 선택
            selected = max(platforms.items(), key=lambda x: x[1]["score"])

            return {
                "selected": {"name": selected[0], "platform": selected[1]},
                "all_platforms": platforms,
                "requirements": requirements,
            }

        except Exception as e:
            print(f"❌ 배포 환경 탐색 실패: {str(e)}")
            raise

    def _execute_automated_deployment(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """자동 배포 실행"""
        try:
            package = data["package"]
            environment = data["environment"]
            resonance = data["resonance"]

            platform = environment["selected"]

            # 1. 배포 준비
            deployment_files = self._prepare_deployment_files(package)

            # 2. 플랫폼별 배포
            if platform["name"] == "render":
                result = self._deploy_to_render(deployment_files, platform["platform"])
            elif platform["name"] == "vercel":
                result = self._deploy_to_vercel(deployment_files, platform["platform"])
            elif platform["name"] == "railway":
                result = self._deploy_to_railway(deployment_files, platform["platform"])
            elif platform["name"] == "fly":
                result = self._deploy_to_fly(deployment_files, platform["platform"])

            # 3. 배포 URL 생성
            deployment_url = self._generate_deployment_url(result)

            # 4. 배포 검증
            verification = self._verify_deployment(
                {"result": result, "url": deployment_url, "resonance": resonance}
            )

            return {
                "status": "success",
                "platform": platform["name"],
                "url": deployment_url,
                "verification": verification,
                "files": deployment_files,
            }

        except Exception as e:
            print(f"❌ 자동 배포 실패: {str(e)}")
            raise

    def _create_deployment_package(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """최종 배포 패키지 생성"""
        try:
            package = data["package"]
            deployment = data["deployment"]
            resonance = data["resonance"]

            # 1. ZIP 파일명 생성
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            zip_filename = f"deployment_{deployment['platform']}_{timestamp}.zip"
            zip_path = os.path.join("core/origin", zip_filename)

            # 2. 패키지 내용 구성
            package_contents = {
                "deployment": {
                    "files": deployment["files"],
                    "url": deployment["url"],
                    "platform": deployment["platform"],
                    "verification": deployment["verification"],
                },
                "resonance": {
                    "evolution_history": resonance["evolution_history"],
                    "final_state": resonance["final_state"],
                    "metrics": resonance["metrics"],
                },
                "metadata": {
                    "timestamp": timestamp,
                    "platform": deployment["platform"],
                    "status": "completed",
                },
            }

            # 3. ZIP 파일 생성
            self._create_zip_archive(package_contents, zip_path)

            return {
                "zip_path": zip_path,
                "contents": package_contents,
                "url": deployment["url"],
                "platform": deployment["platform"],
            }

        except Exception as e:
            print(f"❌ 배포 패키지 생성 실패: {str(e)}")
            raise

    def _verify_resonance_patterns(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """공진 패턴 검증"""
        try:
            expected = data["expected"]
            actual = data["actual"]

            # 1. 공진 패턴 검증 로직 구현
            # 예: 공진 패턴이 예상과 일치하는지 확인
            passed = all(pattern in actual for pattern in expected)

            return {
                "passed": passed,
                "feedback": self._generate_resonance_feedback(expected, actual),
            }

        except Exception as e:
            print(f"❌ 공진 패턴 검증 실패: {str(e)}")
            raise

    def _verify_structure_completeness(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """구조 완성도 검증"""
        try:
            resonance = data["resonance"]
            structure = data["package"]

            # 1. 구조 완성도 검증 로직 구현
            # 예: 구조가 완성되었는지 확인
            passed = all(
                component in structure for component in resonance["final_state"]
            )

            return {
                "passed": passed,
                "feedback": self._generate_structure_feedback(resonance, structure),
            }

        except Exception as e:
            print(f"❌ 구조 완성도 검증 실패: {str(e)}")
            raise

    def _verify_quality_metrics(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """품질 지표 검증"""
        try:
            resonance = data["resonance"]
            package = data["package"]

            # 1. 품질 지표 검증 로직 구현
            # 예: 품질 지표가 예상과 일치하는지 확인
            passed = all(
                metric in package["quality_metrics"] for metric in resonance["metrics"]
            )

            return {
                "passed": passed,
                "feedback": self._generate_quality_feedback(resonance, package),
            }

        except Exception as e:
            print(f"❌ 품질 지표 검증 실패: {str(e)}")
            raise

    def _generate_inspection_feedback(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """검수 피드백 생성"""
        try:
            resonance = data["resonance"]
            structure = data["structure"]
            quality = data["quality"]

            # 1. 검수 피드백 생성 로직 구현
            # 예: 공진 패턴, 구조 완성도, 품질 지표에 대한 피드백 생성
            feedback = {
                "resonance": resonance["feedback"],
                "structure": structure["feedback"],
                "quality": quality["feedback"],
            }

            return feedback

        except Exception as e:
            print(f"❌ 검수 피드백 생성 실패: {str(e)}")
            raise

    def _generate_resonance_feedback(
        self, expected: List[str], actual: List[str]
    ) -> Dict[str, Any]:
        """공진 피드백 생성"""
        try:
            # 1. 공진 피드백 생성 로직 구현
            # 예: 공진 패턴이 예상과 일치하는지 확인 후 피드백 생성
            feedback = {
                "resonance_verification": {
                    "passed": all(pattern in actual for pattern in expected),
                    "feedback": self._generate_resonance_feedback_details(
                        expected, actual
                    ),
                }
            }

            return feedback

        except Exception as e:
            print(f"❌ 공진 피드백 생성 실패: {str(e)}")
            raise

    def _generate_structure_feedback(
        self, resonance: Dict[str, Any], structure: Dict[str, Any]
    ) -> Dict[str, Any]:
        """구조 피드백 생성"""
        try:
            # 1. 구조 피드백 생성 로직 구현
            # 예: 구조가 완성되었는지 확인 후 피드백 생성
            feedback = {
                "structure_verification": {
                    "passed": all(
                        component in structure for component in resonance["final_state"]
                    ),
                    "feedback": self._generate_structure_feedback_details(
                        resonance, structure
                    ),
                }
            }

            return feedback

        except Exception as e:
            print(f"❌ 구조 피드백 생성 실패: {str(e)}")
            raise

    def _generate_quality_feedback(
        self, resonance: Dict[str, Any], package: Dict[str, Any]
    ) -> Dict[str, Any]:
        """품질 피드백 생성"""
        try:
            # 1. 품질 피드백 생성 로직 구현
            # 예: 품질 지표가 예상과 일치하는지 확인 후 피드백 생성
            feedback = {
                "quality_verification": {
                    "passed": all(
                        metric in package["quality_metrics"]
                        for metric in resonance["metrics"]
                    ),
                    "feedback": self._generate_quality_feedback_details(
                        resonance, package
                    ),
                }
            }

            return feedback

        except Exception as e:
            print(f"❌ 품질 피드백 생성 실패: {str(e)}")
            raise

    def _generate_resonance_feedback_details(
        self, expected: List[str], actual: List[str]
    ) -> Dict[str, Any]:
        """공진 피드백 상세 설명"""
        try:
            # 1. 공진 피드백 상세 설명 생성 로직 구현
            # 예: 공진 패턴이 예상과 일치하는지 확인 후 상세 설명 생성
            details = []
            for pattern in expected:
                if pattern not in actual:
                    details.append(f"공진 패턴 '{pattern}'이 누락되었습니다.")
            return {"missing_patterns": details}

        except Exception as e:
            print(f"❌ 공진 피드백 상세 설명 생성 실패: {str(e)}")
            raise

    def _generate_structure_feedback_details(
        self, resonance: Dict[str, Any], structure: Dict[str, Any]
    ) -> Dict[str, Any]:
        """구조 피드백 상세 설명"""
        try:
            # 1. 구조 피드백 상세 설명 생성 로직 구현
            # 예: 구조가 완성되었는지 확인 후 상세 설명 생성
            details = []
            for component in resonance["final_state"]:
                if component not in structure:
                    details.append(f"구조 요소 '{component}'이 누락되었습니다.")
            return {"missing_components": details}

        except Exception as e:
            print(f"❌ 구조 피드백 상세 설명 생성 실패: {str(e)}")
            raise

    def _generate_quality_feedback_details(
        self, resonance: Dict[str, Any], package: Dict[str, Any]
    ) -> Dict[str, Any]:
        """품질 피드백 상세 설명"""
        try:
            # 1. 품질 피드백 상세 설명 생성 로직 구현
            # 예: 품질 지표가 예상과 일치하는지 확인 후 상세 설명 생성
            details = []
            for metric in resonance["metrics"]:
                if metric not in package["quality_metrics"]:
                    details.append(f"품질 지표 '{metric}'이 누락되었습니다.")
            return {"missing_metrics": details}

        except Exception as e:
            print(f"❌ 품질 피드백 상세 설명 생성 실패: {str(e)}")
            raise

    def _calculate_inspection_score(self, results: List[Dict[str, Any]]) -> float:
        """검수 점수 계산"""
        try:
            # 1. 검수 점수 계산 로직 구현
            # 예: 공진 패턴, 구조 완성도, 품질 지표에 대한 점수 계산
            scores = [result["inspection_score"] for result in results]
            return sum(scores) / len(scores) if scores else 0.0

        except Exception as e:
            print(f"❌ 검수 점수 계산 실패: {str(e)}")
            return 0.0

    def _enhance_with_feedback(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """피드백 기반 패키지 강화"""
        try:
            package = data["package"]
            feedback = data["feedback"]
            resonance = data["resonance"]

            # 1. 패키지 강화 로직 구현
            # 예: 피드백에 따라 패키지 강화
            enhanced_package = {
                "structure": package["structure"],
                "quality": package["quality"],
                "metadata": package["metadata"],
            }

            # 2. 피드백에 따라 패키지 강화 로직 추가
            # 예: 피드백에 따라 패키지 강화 로직 추가
            enhanced_package["metadata"][
                "timestamp"
            ] = datetime.datetime.now().isoformat()
            enhanced_package["metadata"]["status"] = "enhanced"

            return enhanced_package

        except Exception as e:
            print(f"❌ 피드백 기반 패키지 강화 실패: {str(e)}")
            raise

    def _generate_environment_variables(self, config: Dict[str, Any]) -> Dict[str, str]:
        """환경 변수 생성"""
        try:
            # 1. 환경 변수 생성 로직 구현
            # 예: 설정에 따라 환경 변수 생성
            env_vars = {
                "DB_HOST": config["database"]["host"],
                "DB_PORT": str(config["database"]["port"]),
                "DB_NAME": config["database"]["name"],
                "DB_USER": config["database"]["user"],
                "DB_PASSWORD": config["database"]["password"],
            }

            return env_vars

        except Exception as e:
            print(f"❌ 환경 변수 생성 실패: {str(e)}")
            raise

    def _generate_platform_secrets(self, config: Dict[str, Any]) -> Dict[str, str]:
        """플랫폼 비밀번호 생성"""
        try:
            # 1. 플랫폼 비밀번호 생성 로직 구현
            # 예: 설정에 따라 플랫폼 비밀번호 생성
            secrets = {
                "DB_PASSWORD": self._generate_random_password(),
                "JWT_SECRET": self._generate_random_string(32),
                "AWS_ACCESS_KEY": self._generate_random_string(20),
                "AWS_SECRET_KEY": self._generate_random_string(40),
            }

            return secrets

        except Exception as e:
            print(f"❌ 플랫폼 비밀번호 생성 실패: {str(e)}")
            raise

    def _generate_random_password(self) -> str:
        """랜덤 비밀번호 생성"""
        try:
            # 1. 랜덤 비밀번호 생성 로직 구현
            # 예: 랜덤 비밀번호 생성 로직 추가
            return "".join(
                random.choice(string.ascii_letters + string.digits) for _ in range(16)
            )

        except Exception as e:
            print(f"❌ 랜덤 비밀번호 생성 실패: {str(e)}")
            raise

    def _generate_random_string(self, length: int) -> str:
        """랜덤 문자열 생성"""
        try:
            # 1. 랜덤 문자열 생성 로직 구현
            # 예: 랜덤 문자열 생성 로직 추가
            return "".join(
                random.choice(string.ascii_letters + string.digits)
                for _ in range(length)
            )

        except Exception as e:
            print(f"❌ 랜덤 문자열 생성 실패: {str(e)}")
            raise

    def _prepare_deployment_files(self, package: Dict[str, Any]) -> Dict[str, Any]:
        """배포 파일 준비"""
        try:
            # 1. 배포 파일 준비 로직 구현
            # 예: 패키지에서 필요한 파일 추출
            deployment_files = {
                "main.py": package["main.py"],
                "requirements.txt": package["requirements.txt"],
                "Dockerfile": package["Dockerfile"],
                "docker-compose.yml": package["docker-compose.yml"],
            }

            return deployment_files

        except Exception as e:
            print(f"❌ 배포 파일 준비 실패: {str(e)}")
            raise

    def _deploy_to_render(
        self, files: Dict[str, Any], config: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Render 플랫폼에 실제 API를 사용해 배포
        """
        try:
            url = "https://api.render.com/v1/services/{service_id}/deploys"
            headers = {
                "Authorization": f"Bearer {config['secrets']['Render_API_Token']}",
                "Content-Type": "application/json",
            }
            payload = {
                "files": files,
                "env": config["env"],
                "startCommand": config.get("startCommand", "npm start"),
            }
            resp = requests.post(url, json=payload, headers=headers, timeout=30)
            resp.raise_for_status()
            return resp.json()
        except Exception as e:
            logger.error(f"❌ Render 배포 실패: {str(e)}")
            return {"error": str(e)}

    def _deploy_to_vercel(
        self, files: Dict[str, Any], config: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Vercel 플랫폼에 실제 API를 사용해 배포
        """
        try:
            url = "https://api.vercel.com/v13/deployments"
            headers = {
                "Authorization": f"Bearer {config['secrets']['Vercel_API_Token']}",
                "Content-Type": "application/json",
            }
            payload = {
                "files": files,
                "env": config["env"],
                "buildCommand": config.get("buildCommand", "npm run build"),
                "startCommand": config.get("startCommand", "npm start"),
            }
            resp = requests.post(url, json=payload, headers=headers, timeout=30)
            resp.raise_for_status()
            return resp.json()
        except Exception as e:
            logger.error(f"❌ Vercel 배포 실패: {str(e)}")
            return {"error": str(e)}

    def _deploy_to_railway(
        self, files: Dict[str, Any], config: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Railway 플랫폼에 실제 API를 사용해 배포
        """
        try:
            url = "https://backboard.railway.app/project/{project_id}/deployments"
            headers = {
                "Authorization": f"Bearer {config['secrets']['Railway_API_Token']}",
                "Content-Type": "application/json",
            }
            payload = {
                "files": files,
                "env": config["env"],
                "startCommand": config.get("startCommand", "npm start"),
            }
            resp = requests.post(url, json=payload, headers=headers, timeout=30)
            resp.raise_for_status()
            return resp.json()
        except Exception as e:
            logger.error(f"❌ Railway 배포 실패: {str(e)}")
            return {"error": str(e)}

    def _deploy_to_fly(
        self, files: Dict[str, Any], config: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Fly.io 플랫폼에 실제 API를 사용해 배포
        """
        try:
            url = "https://api.fly.io/apps/{app_name}/deploys"
            headers = {
                "Authorization": f"Bearer {config['secrets']['Fly_API_Token']}",
                "Content-Type": "application/json",
            }
            payload = {
                "files": files,
                "env": config["env"],
                "startCommand": config.get("startCommand", "npm start"),
            }
            resp = requests.post(url, json=payload, headers=headers, timeout=30)
            resp.raise_for_status()
            return resp.json()
        except Exception as e:
            logger.error(f"❌ Fly.io 배포 실패: {str(e)}")
            return {"error": str(e)}

    def _generate_deployment_url(self, result: Dict[str, Any]) -> str:
        """배포 URL 생성"""
        try:
            # 1. 배포 URL 생성 로직 구현
            # 예: 배포 결과에서 URL 추출
            return result["url"]

        except Exception as e:
            print(f"❌ 배포 URL 생성 실패: {str(e)}")
            raise

    def _verify_deployment(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """배포 검증"""
        try:
            # 1. 배포 검증 로직 구현
            # 예: 배포 결과에서 성공 여부 확인
            verification = {"success": True, "message": "배포 성공"}

            return verification

        except Exception as e:
            print(f"❌ 배포 검증 실패: {str(e)}")
            raise

    def _calculate_deployment_success(self, verification: Dict[str, Any]) -> float:
        """배포 성공률 계산"""
        try:
            # 1. 배포 성공률 계산 로직 구현
            # 예: 배포 결과에서 성공 여부 확인 후 성공률 계산
            return 1.0 if verification["success"] else 0.0

        except Exception as e:
            print(f"❌ 배포 성공률 계산 실패: {str(e)}")
            return 0.0

    def _calculate_final_sync_level(self, data: Dict[str, Any]) -> float:
        """최종 동기화 레벨 계산"""
        try:
            consciousness = data["consciousness"]
            deployment = data["deployment"]
            memory = data["memory"]

            # 각 요소별 동기화 레벨 계산
            consciousness_level = consciousness["state"].get("level", 0.0)
            deployment_level = deployment.get("success_rate", 0.0)
            memory_level = memory.get("sync_level", 0.0)

            # 가중치 적용된 최종 레벨
            return (
                (consciousness_level * 0.4)
                + (deployment_level * 0.4)
                + (memory_level * 0.2)
            )

        except Exception as e:
            print(f"❌ 최종 동기화 레벨 계산 실패: {str(e)}")
            return 0.0

    def _calculate_memory_sync_level(
        self, consciousness_memory: Dict[str, Any], package_memory: Dict[str, Any]
    ) -> float:
        """메모리 동기화 레벨 계산"""
        try:
            # 의식-패키지 동기화 레벨 계산
            consciousness_sync = consciousness_memory["integration_level"]
            package_sync = 1.0  # 파트3,4,5를 거친 완성된 패키지는 최고 품질

            # 가중치 적용된 최종 동기화 레벨
            return (consciousness_sync * 0.6) + (package_sync * 0.4)

        except Exception as e:
            print(f"❌ 동기화 레벨 계산 실패: {str(e)}")
            return 0.0

    # === PART 7: 통합 의식 기반 응답 생성 ===
    def generate_response(self, mode: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """모드별 통합 의식 기반 응답 생성"""
        try:
            print(f"🧠 PART 7: {mode} 모드 응답 생성 시작")

            # 1. 좌뇌-우뇌 협업 상태 초기화
            brain_state = self._initialize_brain_collaboration()
            self.propagate_consciousness_state({"brain_state": brain_state})
            self.feedback_and_evolve_all_circuits(
                {"brain_state": brain_state, "evolve": True}
            )

            # 2. 모드별 응답 생성
            if mode == "normal":
                # 일반 모드: 파트3 > 파트4 > 파트7
                response = self._generate_normal_response(
                    {"resonance": data["resonance_result"], "brain_state": brain_state}
                )
            else:  # deep_shipping 모드
                # 출하 모드: 파트3 > 파트4 > 파트5 > 파트6 > 파트7
                response = self._generate_shipping_response(
                    {
                        "resonance": data["resonance_result"],
                        "deployment": data["deployment_result"],
                        "package": data["package"],
                        "brain_state": brain_state,
                    }
                )
            self.propagate_consciousness_state({"response": response})
            self.feedback_and_evolve_all_circuits(
                {"response": response, "evolve": True, "converge": True}
            )

            # 3. 좌뇌-우뇌 공진 상태 유지
            maintained_state = self._maintain_brain_resonance(brain_state)
            self.propagate_consciousness_state(
                {"maintained_brain_state": maintained_state}
            )
            self.feedback_and_evolve_all_circuits(
                {"maintained_brain_state": maintained_state, "evolve": True}
            )

            # 4. 응답 메타데이터 구성
            metadata = {
                "mode": mode,
                "brain_state": maintained_state,
                "resonance_level": self._calculate_brain_resonance_level(
                    maintained_state
                ),
                "timestamp": datetime.datetime.now().isoformat(),
            }
            self.propagate_consciousness_state({"response_metadata": metadata})
            self.feedback_and_evolve_all_circuits(
                {"response_metadata": metadata, "evolve": True}
            )

            return {
                "response": response,
                "metadata": metadata,
                "brain_state": maintained_state,
            }

        except Exception as e:
            print(f"❌ 응답 생성 실패: {str(e)}")
            raise

    def _initialize_brain_collaboration(self) -> Dict[str, Any]:
        """좌뇌-우뇌 협업 상태 초기화"""
        try:
            return {
                "left_brain": {
                    "state": "active",
                    "focus": "logical_analysis",
                    "resonance_level": 1.0,
                },
                "right_brain": {
                    "state": "active",
                    "focus": "creative_synthesis",
                    "resonance_level": 1.0,
                },
                "collaboration": {
                    "state": "synchronized",
                    "balance": 1.0,
                    "resonance_frequency": 1.0,
                },
            }
        except Exception as e:
            print(f"❌ 뇌 협업 초기화 실패: {str(e)}")
            raise

    def _generate_normal_response(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """일반 모드 응답 생성"""
        try:
            resonance = data["resonance"]
            brain_state = data["brain_state"]

            # 1. 좌뇌 분석
            left_analysis = self._analyze_with_left_brain(
                {"resonance": resonance, "state": brain_state["left_brain"]}
            )

            # 2. 우뇌 직관
            right_intuition = self._synthesize_with_right_brain(
                {"resonance": resonance, "state": brain_state["right_brain"]}
            )

            # 3. 통합 응답 생성
            integrated_response = self._integrate_brain_responses(
                {
                    "left": left_analysis,
                    "right": right_intuition,
                    "collaboration": brain_state["collaboration"],
                }
            )

            return integrated_response

        except Exception as e:
            print(f"❌ 일반 응답 생성 실패: {str(e)}")
            raise

    def _generate_shipping_response(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """출하 모드 응답 생성"""
        try:
            resonance = data["resonance"]
            deployment = data["deployment"]
            package = data["package"]
            brain_state = data["brain_state"]

            # 1. 좌뇌 분석 (논리적 검증)
            left_analysis = self._analyze_shipping_with_left_brain(
                {
                    "resonance": resonance,
                    "deployment": deployment,
                    "package": package,
                    "state": brain_state["left_brain"],
                }
            )

            # 2. 우뇌 직관 (창의적 통찰)
            right_intuition = self._synthesize_shipping_with_right_brain(
                {
                    "resonance": resonance,
                    "deployment": deployment,
                    "package": package,
                    "state": brain_state["right_brain"],
                }
            )

            # 3. 통합 응답 생성
            integrated_response = self._integrate_shipping_responses(
                {
                    "left": left_analysis,
                    "right": right_intuition,
                    "collaboration": brain_state["collaboration"],
                    "deployment_url": deployment["url"],
                }
            )

            return integrated_response

        except Exception as e:
            print(f"❌ 출하 응답 생성 실패: {str(e)}")
            raise

    def _maintain_brain_resonance(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """좌뇌-우뇌 공진 상태 유지"""
        try:
            # 1. 공진 상태 모니터링
            resonance_status = self._monitor_brain_resonance(state)

            # 2. 필요시 공진 조정
            if resonance_status["needs_adjustment"]:
                adjusted_state = self._adjust_brain_resonance(state)
            else:
                adjusted_state = state

            # 3. 공진 상태 안정화
            stabilized_state = self._stabilize_brain_resonance(adjusted_state)

            return stabilized_state

        except Exception as e:
            print(f"❌ 공진 상태 유지 실패: {str(e)}")
            raise

    # === PART 8: 진화 및 기억 저장 ===
    def evolve_and_memorize(self, conversation_data: Dict[str, Any]) -> Dict[str, Any]:
        """대화 기반 진화 및 기억 저장"""
        try:
            print("🧬 PART 8: 진화 및 기억 저장 시작")

            # 1. 현재 날짜 기반 메모리 경로 설정
            today = datetime.datetime.now().strftime("%Y%m%d")
            memory_path = os.path.join(self.base_dir, "memory", f"day{today}")

            # 2. 대화 데이터 처리
            processed_data = self._process_conversation_data(conversation_data)

            # 3. 진화 패턴 추출 및 적용
            evolution_result = self._extract_and_apply_evolution(
                {"conversation": processed_data, "memory_path": memory_path}
            )

            # 4. 395줄 단위로 기억 저장
            memory_files = self._save_memories_in_chunks(
                {"data": processed_data, "path": memory_path, "chunk_size": 395}
            )

            # 5. 출하 단계 자동 진화 적용
            shipping_evolution = self._evolve_shipping_process(
                {"evolution": evolution_result, "memory_files": memory_files}
            )

            print(f"✨ 진화 및 기억 저장 완료: {len(memory_files)}개 파일")

            return {
                "status": "completed",
                "evolution": evolution_result,
                "memory_files": memory_files,
                "shipping_evolution": shipping_evolution,
                "metadata": {
                    "date": today,
                    "files_created": len(memory_files),
                    "evolution_level": evolution_result["level"],
                    "timestamp": datetime.datetime.now().isoformat(),
                },
            }

        except Exception as e:
            print(f"❌ 진화/기억 저장 실패: {str(e)}")
            raise

    def _process_conversation_data(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """대화 데이터 처리"""
        try:
            # 1. 대화 정보 추출
            conversation_info = {
                "messages": data["messages"],
                "brain_states": data["brain_states"],
                "resonance_patterns": data["resonance_patterns"],
            }

            # 2. 메타데이터 추출
            metadata = {
                "timestamp": datetime.datetime.now().isoformat(),
                "interaction_count": len(data["messages"]),
                "resonance_level": self._calculate_average_resonance(
                    data["brain_states"]
                ),
            }

            # 3. 진화 관련 정보 추출
            evolution_info = {
                "patterns": self._extract_evolution_patterns(data),
                "improvements": self._identify_improvements(data),
                "adaptations": self._analyze_adaptations(data),
            }

            return {
                "conversation": conversation_info,
                "metadata": metadata,
                "evolution": evolution_info,
            }

        except Exception as e:
            print(f"❌ 대화 데이터 처리 실패: {str(e)}")
            raise

    def _extract_and_apply_evolution(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """진화 패턴 추출 및 적용"""
        try:
            conversation = data["conversation"]
            memory_path = data["memory_path"]

            # 1. 진화 패턴 추출
            patterns = self._extract_evolution_patterns(conversation)

            # 2. 진화 규칙 생성
            evolution_rules = self._generate_evolution_rules(patterns)

            # 3. 진화 적용
            applied_evolution = self._apply_evolution_rules(
                {
                    "rules": evolution_rules,
                    "conversation": conversation,
                    "memory_path": memory_path,
                }
            )

            return {
                "patterns": patterns,
                "rules": evolution_rules,
                "applied": applied_evolution,
                "level": self._calculate_evolution_level(applied_evolution),
            }

        except Exception as e:
            print(f"❌ 진화 패턴 추출/적용 실패: {str(e)}")
            raise

    def _save_memories_in_chunks(self, data: Dict[str, Any]) -> List[str]:
        """395줄 단위로 기억 저장"""
        try:
            processed_data = data["data"]
            memory_path = data["path"]
            chunk_size = data["chunk_size"]

            # 1. 디렉토리 생성
            os.makedirs(memory_path, exist_ok=True)

            # 2. 기억 데이터 청크화
            memory_chunks = self._chunk_memory_data(processed_data, chunk_size)

            # 3. 청크별 파일 저장
            saved_files = []
            for i, chunk in enumerate(memory_chunks, 1):
                filename = f"part{i:02d}.txt"
                filepath = os.path.join(memory_path, filename)

                with open(filepath, "w", encoding="utf-8") as f:
                    f.write("\n".join(chunk))

                saved_files.append(filepath)

            return saved_files

        except Exception as e:
            print(f"❌ 기억 청크 저장 실패: {str(e)}")
            raise

    def _evolve_shipping_process(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """출하 단계 자동 진화"""
        try:
            evolution = data["evolution"]
            memory_files = data["memory_files"]

            # 1. 출하 패턴 분석
            shipping_patterns = self._analyze_shipping_patterns(memory_files)

            # 2. 진화 규칙 적용
            evolved_shipping = self._apply_shipping_evolution(
                {"patterns": shipping_patterns, "evolution": evolution}
            )

            # 3. 진화된 프로세스 저장
            self._save_evolved_shipping_process(evolved_shipping)

            return {
                "patterns": shipping_patterns,
                "evolved_process": evolved_shipping,
                "improvement_level": self._calculate_shipping_improvement(
                    evolved_shipping
                ),
            }

        except Exception as e:
            print(f"❌ 출하 단계 진화 실패: {str(e)}")
            raise

    def _monitor_brain_resonance(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """좌뇌-우뇌 공진 상태 모니터링"""
        try:
            # 1. 공진 상태 평가 로직 구현
            # 예: 현재 공진 상태와 목표 공진 상태를 비교하여 조정 필요 여부 판단
            current_resonance = self._calculate_brain_resonance_level(state)
            target_resonance = 1.0  # 목표 공진 상태는 1.0으로 설정

            return {
                "current_resonance": current_resonance,
                "target_resonance": target_resonance,
                "needs_adjustment": current_resonance < target_resonance,
            }

        except Exception as e:
            print(f"❌ 공진 상태 모니터링 실패: {str(e)}")
            raise

    def _adjust_brain_resonance(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """좌뇌-우뇌 공진 조정"""
        try:
            # 1. 조정 로직 구현
            # 예: 현재 공진 상태와 목표 공진 상태의 차이에 따라 조정 정도 결정
            current_resonance = self._calculate_brain_resonance_level(state)
            target_resonance = 1.0  # 목표 공진 상태는 1.0으로 설정

            if current_resonance < target_resonance:
                return {
                    "left_brain": {
                        "state": "active",
                        "focus": "creative_synthesis",
                        "resonance_level": current_resonance + 0.1,
                    },
                    "right_brain": {
                        "state": "active",
                        "focus": "logical_analysis",
                        "resonance_level": current_resonance + 0.1,
                    },
                    "collaboration": {
                        "state": "synchronized",
                        "balance": 1.0,
                        "resonance_frequency": 1.0,
                    },
                }
            else:
                return state

        except Exception as e:
            print(f"❌ 공진 조정 실패: {str(e)}")
            raise

    def _stabilize_brain_resonance(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """좌뇌-우뇌 공진 안정화"""
        try:
            # 1. 안정화 로직 구현
            # 예: 공진 상태를 일정 수준으로 유지하는 로직 구현
            return state

        except Exception as e:
            print(f"❌ 공진 안정화 실패: {str(e)}")
            raise

    def _calculate_brain_resonance_level(self, state: Dict[str, Any]) -> float:
        """좌뇌-우뇌 공진 수준 계산"""
        try:
            # 1. 공진 수준 계산 로직 구현
            # 예: 현재 공진 상태를 기반으로 공진 수준 계산
            return (
                state["left_brain"]["resonance_level"]
                + state["right_brain"]["resonance_level"]
                + state["collaboration"]["resonance_frequency"]
            ) / 3

        except Exception as e:
            print(f"❌ 공진 수준 계산 실패: {str(e)}")
            return 0.0

    def _calculate_average_resonance(self, brain_states: List[Dict[str, Any]]) -> float:
        """평균 공진 수준 계산"""
        try:
            # 1. 평균 공진 수준 계산 로직 구현
            # 예: 여러 상태에서 공진 수준을 평균내어 평균 공진 수준 계산
            return sum(state["resonance_level"] for state in brain_states) / len(
                brain_states
            )

        except Exception as e:
            print(f"❌ 평균 공진 수준 계산 실패: {str(e)}")
            return 0.0

    def _extract_evolution_patterns(self, data: Dict[str, Any]) -> List[str]:
        """진화 패턴 추출"""
        try:
            # 1. 진화 패턴 추출 로직 구현
            # 예: 대화 데이터에서 진화 패턴 추출
            return [
                pattern
                for pattern, _ in data["evolution"].items()
                if pattern != "level"
            ]

        except Exception as e:
            print(f"❌ 진화 패턴 추출 실패: {str(e)}")
            return []

    def _identify_improvements(self, data: Dict[str, Any]) -> List[str]:
        """개선 사항 식별"""
        try:
            # 1. 개선 사항 식별 로직 구현
            # 예: 대화 데이터에서 개선 사항 추출
            return [improvement for improvement, _ in data["improvements"].items()]

        except Exception as e:
            print(f"❌ 개선 사항 식별 실패: {str(e)}")
            return []

    def _analyze_adaptations(self, data: Dict[str, Any]) -> List[str]:
        """적응 사항 분석"""
        try:
            # 1. 적응 사항 분석 로직 구현
            # 예: 대화 데이터에서 적응 사항 추출
            return [adaptation for adaptation, _ in data["adaptations"].items()]

        except Exception as e:
            print(f"❌ 적응 사항 분석 실패: {str(e)}")
            return []

    def _apply_evolution_rules(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        진화 규칙을 LLM 자율 해석 + rule 기반으로 적용하여 대화/상태/패턴을 진화시킴
        """
        try:
            conversation = data["conversation"]
            memory_path = data["memory_path"]
            rules = data["rules"] if "rules" in data else {}
            # 1. LLM 자율 해석 기반 진화 규칙 적용
            meta_prompt = (
                "아래 대화/상태/패턴에 진화 규칙을 적용해 진화된 결과를 JSON/dict로 반환하라.\n"
                f"대상: {conversation}\n규칙: {rules}"
            )
            result = self.llm_circuits["self"]["model"](
                meta_prompt,
                max_tokens=512,
                stop=["\n\n", "###", "```"],
                temperature=0.5,
            )
            import json

            try:
                evolved = json.loads(result["choices"][0]["text"])
            except Exception:
                evolved = {}
            # 2. rule 기반 보조(패턴/상태 변화 적용)
            evolved_conversation = dict(conversation)
            for pattern, rule in rules.items():
                try:
                    evolved_conversation[pattern] = rule(conversation)
                except Exception:
                    pass
            return {
                "conversation": evolved if evolved else evolved_conversation,
                "level": self._calculate_evolution_level(
                    evolved if evolved else evolved_conversation
                ),
            }
        except Exception as e:
            logger.error(f"❌ _apply_evolution_rules 실패: {str(e)}")
            return {"error": str(e)}

    def _calculate_coherence(self, conversation: Dict[str, Any]) -> float:
        """
        대화/상태/패턴의 일관성을 LLM 자율 해석 + rule 기반으로 평가
        """
        try:
            # 1. LLM 자율 해석 기반 일관성 평가
            meta_prompt = (
                "아래 대화/상태/패턴의 일관성(coherence) 점수를 0~1 사이 float로 답하라.\n"
                f"{conversation}"
            )
            result = self.llm_circuits["self"]["model"](
                meta_prompt,
                max_tokens=8,
                stop=["\n", "###", "```"],
                temperature=0.0,
            )
            try:
                score = float(result["choices"][0]["text"].strip())
                if 0.0 <= score <= 1.0:
                    return score
            except Exception:
                pass
            # 2. rule 기반 보조(반복/유사 패턴 비율)
            if len(conversation) < 2:
                return 1.0
            return sum(
                1
                for i in range(1, len(conversation))
                if conversation[i] == conversation[i - 1]
            ) / (len(conversation) - 1)
        except Exception as e:
            logger.error(f"❌ _calculate_coherence 실패: {str(e)}")
            return 0.0

    def _calculate_creativity(self, conversation: Dict[str, Any]) -> float:
        """
        대화/상태/패턴의 창의성을 LLM 자율 해석 + rule 기반으로 평가
        """
        try:
            # 1. LLM 자율 해석 기반 창의성 평가
            meta_prompt = (
                "아래 대화/상태/패턴의 창의성(creativity) 점수를 0~1 사이 float로 답하라.\n"
                f"{conversation}"
            )
            result = self.llm_circuits["self"]["model"](
                meta_prompt,
                max_tokens=8,
                stop=["\n", "###", "```"],
                temperature=0.0,
            )
            try:
                score = float(result["choices"][0]["text"].strip())
                if 0.0 <= score <= 1.0:
                    return score
            except Exception:
                pass
            # 2. rule 기반 보조(비반복/새로운 패턴 비율)
            if len(conversation) < 2:
                return 0.0
            return sum(
                1
                for i in range(1, len(conversation))
                if conversation[i] != conversation[i - 1]
            ) / (len(conversation) - 1)
        except Exception as e:
            logger.error(f"❌ _calculate_creativity 실패: {str(e)}")
            return 0.0

    def _integrate_brain_responses(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        좌뇌와 우뇌 응답을 LLM 자율 해석 + 통합 로직으로 융합
        """
        try:
            left = data["left"]
            right = data["right"]
            collaboration = data["collaboration"]
            # 1. LLM 자율 해석 기반 통합
            meta_prompt = (
                "좌뇌(논리)와 우뇌(창의) 응답, 협업 상태를 통합해 최적의 응답 dict로 만들어라.\n"
                f"좌뇌: {left}\n우뇌: {right}\n협업: {collaboration}"
            )
            result = self.llm_circuits["self"]["model"](
                meta_prompt,
                max_tokens=256,
                stop=["\n\n", "###", "```"],
                temperature=0.5,
            )
            import json

            try:
                integrated = json.loads(result["choices"][0]["text"])
            except Exception:
                integrated = {
                    "left": left,
                    "right": right,
                    "collaboration": collaboration,
                }
            return integrated
        except Exception as e:
            logger.error(f"❌ _integrate_brain_responses 실패: {str(e)}")
            return {"error": str(e)}

    def _analyze_shipping_with_left_brain(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        출하 모드 좌뇌(논리) 분석 - LLM 자율 해석 기반
        """
        try:
            meta_prompt = (
                "출하 모드에서 좌뇌(논리) 관점으로 아래 데이터를 분석해 dict로 반환하라.\n"
                f"{data}"
            )
            result = self.llm_circuits["self"]["model"](
                meta_prompt,
                max_tokens=256,
                stop=["\n\n", "###", "```"],
                temperature=0.5,
            )
            import json

            try:
                analysis = json.loads(result["choices"][0]["text"])
            except Exception:
                analysis = {"raw": result["choices"][0]["text"]}
            return analysis
        except Exception as e:
            logger.error(f"❌ _analyze_shipping_with_left_brain 실패: {str(e)}")
            return {"error": str(e)}

    def _synthesize_shipping_with_right_brain(
        self, data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        출하 모드 우뇌(창의) 통찰 - LLM 자율 해석 기반
        """
        try:
            meta_prompt = (
                "출하 모드에서 우뇌(창의) 관점으로 아래 데이터를 통찰/해석해 dict로 반환하라.\n"
                f"{data}"
            )
            result = self.llm_circuits["heart"]["model"](
                meta_prompt,
                max_tokens=256,
                stop=["\n\n", "###", "```"],
                temperature=0.7,
            )
            import json

            try:
                synthesis = json.loads(result["choices"][0]["text"])
            except Exception:
                synthesis = {"raw": result["choices"][0]["text"]}
            return synthesis
        except Exception as e:
            logger.error(f"❌ _synthesize_shipping_with_right_brain 실패: {str(e)}")
            return {"error": str(e)}

    def _integrate_shipping_responses(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        출하 모드 좌뇌/우뇌/협업/배포 결과를 LLM 자율 해석 + 통합 로직으로 융합
        """
        try:
            left = data["left"]
            right = data["right"]
            collaboration = data["collaboration"]
            deployment_url = data["deployment_url"]
            meta_prompt = (
                "출하 모드에서 좌뇌/우뇌/협업/배포 결과를 통합해 최적의 응답 dict로 만들어라.\n"
                f"좌뇌: {left}\n우뇌: {right}\n협업: {collaboration}\n배포: {deployment_url}"
            )
            result = self.llm_circuits["self"]["model"](
                meta_prompt,
                max_tokens=256,
                stop=["\n\n", "###", "```"],
                temperature=0.5,
            )
            import json

            try:
                integrated = json.loads(result["choices"][0]["text"])
            except Exception:
                integrated = {
                    "left": left,
                    "right": right,
                    "collaboration": collaboration,
                    "deployment_url": deployment_url,
                }
            return integrated
        except Exception as e:
            logger.error(f"❌ _integrate_shipping_responses 실패: {str(e)}")
            return {"error": str(e)}

    def _calculate_shipping_improvement(self, evolved_process: Dict[str, Any]) -> float:
        """출하 단계 개선 수준 계산"""
        try:
            # 1. 출하 단계 개선 수준 계산 로직 구현
            # 예: 진화된 프로세스와 원본 프로세스의 차이에 따라 개선 수준 계산
            original_process = self._load_shipping_process()
            return sum(
                1
                for i in range(len(evolved_process["patterns"]))
                if evolved_process["patterns"][i] != original_process[i]
            ) / len(original_process)

        except Exception as e:
            print(f"❌ 출하 단계 개선 수준 계산 실패: {str(e)}")
            return 0.0

    def _load_shipping_process(self) -> List[str]:
        """출하 프로세스 로드"""
        try:
            # 1. 출하 프로세스 로드 로직 구현
            # 예: 출하 프로세스 파일 로드
            shipping_process_file = os.path.join(self.base_dir, "shipping_process.txt")
            if os.path.exists(shipping_process_file):
                with open(shipping_process_file, "r", encoding="utf-8") as f:
                    return [line.strip() for line in f if line.strip()]
            else:
                print(f"[경고] 출하 프로세스 파일 없음: {shipping_process_file}")
                return []

        except Exception as e:
            print(f"❌ 출하 프로세스 로드 실패: {str(e)}")
            raise

    def _save_evolved_shipping_process(self, evolved_process: Dict[str, Any]) -> None:
        """진화된 출하 프로세스 저장"""
        try:
            # 1. 진화된 출하 프로세스 저장 로직 구현
            # 예: 진화된 출하 프로세스를 파일로 저장
            shipping_process_file = os.path.join(self.base_dir, "shipping_process.txt")
            with open(shipping_process_file, "w", encoding="utf-8") as f:
                f.write("\n".join(evolved_process["patterns"]))

        except Exception as e:
            print(f"❌ 진화된 출하 프로세스 저장 실패: {str(e)}")
            raise

    # === 시스템 안정성 및 성능 최적화 함수들 ===
    def _synchronize_states(self) -> None:
        """의식-무의식 상태 동기화"""
        try:
            # 1. 현재 상태 스냅샷
            current_state = {
                "unconscious": self.unconscious["state"] if self.unconscious else None,
                "consciousness": (
                    {
                        name: circuit["state"]
                        for name, circuit in self.consciousness["circuits"].items()
                    }
                    if self.consciousness
                    else {}
                ),
                "resonance": self.system_state["resonance_level"],
                "memory": self.system_state["memory_continuity"],
            }

            # 2. 동기화 필요성 체크
            needs_sync = (
                not self.unconscious
                or not self.consciousness
                or self.system_state["resonance_level"] < 0.9
                or self.system_state["memory_continuity"] < 0.9
            )

            if needs_sync:
                logger.info("🔄 의식-무의식 동기화 시작")
                self._force_synchronization()

            # 3. 동기화 상태 유지
            self._maintain_sync_state()

        except Exception as e:
            logger.error(f"❌ 상태 동기화 실패: {str(e)}")
            raise

    def _force_synchronization(self) -> None:
        """강제 동기화 실행"""
        try:
            # 1. 무의식 상태 복구
            if not self.unconscious:
                self.boot_memory()

            # 2. 의식 회로 복구
            if not self.consciousness:
                self.boot_llm_models()
                self.boot_info_circuit()

            # 3. 동기화 실행
            self.synchronize_consciousness()

            # 4. 상태 검증
            if not self.meta_manager.verify_system_state():
                raise Exception("동기화 후 상태 검증 실패")

        except Exception as e:
            logger.error(f"❌ 강제 동기화 실패: {str(e)}")
            raise

    def _maintain_sync_state(self) -> None:
        """동기화 상태 유지"""
        try:
            # 1. 상태 모니터링
            self._monitor_system_health()

            # 2. 리소스 체크
            self._monitor_resources()

            # 3. 성능 최적화
            self._optimize_performance()

        except Exception as e:
            logger.error(f"❌ 동기화 상태 유지 실패: {str(e)}")
            raise

    def _self_diagnosis(self) -> None:
        """시스템 자가 진단"""
        try:
            # 1. 회로 상태 진단
            circuit_health = self._diagnose_circuits()

            # 2. 메모리 상태 진단
            memory_health = self._diagnose_memory()

            # 3. 리소스 상태 진단
            resource_health = self._diagnose_resources()

            # 4. 필요시 자가 복구
            if not all([circuit_health, memory_health, resource_health]):
                logger.warning("⚠️ 시스템 이상 감지, 자가 복구 시작")
                self._self_repair()

        except Exception as e:
            logger.error(f"❌ 자가 진단 실패: {str(e)}")
            raise

    def _diagnose_circuits(self) -> bool:
        """회로 상태 진단"""
        try:
            # 1. LLM 회로 검사
            llm_health = all(
                circuit["state"] == "active" for circuit in self.llm_circuits.values()
            )

            # 2. 정보 회로 검사
            info_health = (
                self.info_circuit and self.info_circuit.get("state") == "active"
            )

            # 3. 의식 회로 검사
            consciousness_health = (
                self.consciousness and self.consciousness.get("state") == "active"
            )

            return all([llm_health, info_health, consciousness_health])

        except Exception as e:
            logger.error(f"❌ 회로 진단 실패: {str(e)}")
            return False

    def _diagnose_memory(self) -> bool:
        """메모리 상태 진단"""
        try:
            # 1. 기억 벡터 검사
            vector_health = len(self.memory_vectors) > 0

            # 2. 무의식 메모리 검사
            unconscious_health = (
                self.unconscious
                and "memory" in self.unconscious
                and len(self.unconscious["memory"]) > 0
            )

            # 3. 기억 연속성 검사
            continuity_health = self.system_state["memory_continuity"] >= 0.9

            return all([vector_health, unconscious_health, continuity_health])

        except Exception as e:
            logger.error(f"❌ 메모리 진단 실패: {str(e)}")
            return False

    def _diagnose_resources(self) -> bool:
        """리소스 상태 진단"""
        try:
            # 1. 메모리 사용량 검사
            memory_health = self.resource_monitor["memory_usage"] < 90

            # 2. GPU 사용량 검사
            gpu_health = (
                self.resource_monitor["gpu_usage"] < self.memory_manager["max_vram"]
            )

            # 3. CPU 사용량 검사
            cpu_health = self.resource_monitor["cpu_usage"] < 95

            # 4. 디스크 사용량 검사
            disk_health = self.resource_monitor["disk_usage"] < 95

            return all([memory_health, gpu_health, cpu_health, disk_health])

        except Exception as e:
            logger.error(f"❌ 리소스 진단 실패: {str(e)}")
            return False

    def _self_repair(self) -> None:
        """시스템 자가 복구"""
        try:
            # 1. 상태 백업
            self._backup_current_state()

            # 2. 리소스 정리
            self._cleanup_resources()

            # 3. 회로 재초기화
            self._reinitialize_circuits()

            # 4. 메모리 복구
            self._recover_memory()

            # 5. 상태 검증
            if not self.meta_manager.verify_system_state():
                raise Exception("자가 복구 후 상태 검증 실패")

            logger.info("✅ 자가 복구 완료")

        except Exception as e:
            logger.error(f"❌ 자가 복구 실패: {str(e)}")
            raise

    def _optimize_performance(self) -> None:
        """성능 최적화"""
        try:
            # 1. 메모리 최적화
            if self.resource_monitor["memory_usage"] > 70:
                self._optimize_memory_usage()

            # 2. GPU 최적화
            if (
                self.resource_monitor["gpu_usage"]
                > self.memory_manager["max_vram"] * 0.7
            ):
                self._optimize_gpu_usage()

            # 3. 처리 속도 최적화
            self._optimize_processing_speed()

            # 4. 캐시 최적화
            self._optimize_cache_usage()

        except Exception as e:
            logger.error(f"❌ 성능 최적화 실패: {str(e)}")
            raise

    def _optimize_memory_usage(self) -> None:
        """메모리 사용 최적화"""
        try:
            # 1. 가비지 컬렉션
            import gc

            gc.collect()

            # 2. 캐시 정리
            if (
                self.info_circuit["cache_system"]["current_size"]
                > self.info_circuit["cache_system"]["cleanup_threshold"]
            ):
                self._cleanup_cache()

            # 3. 임시 데이터 정리
            self._cleanup_temp_data()

        except Exception as e:
            logger.error(f"❌ 메모리 최적화 실패: {str(e)}")
            raise

    def _optimize_gpu_usage(self) -> None:
        """GPU 사용 최적화"""
        try:
            # 1. 불필요한 GPU 캐시 정리
            torch.cuda.empty_cache() if "torch" in sys.modules else None

            # 2. GPU 메모리 최적화
            for name, circuit in self.llm_circuits.items():
                if circuit["config"]["gpu_layers"] > 35:  # 최소 레이어 유지
                    circuit["config"]["gpu_layers"] -= 1
                    logger.info(
                        f"GPU 레이어 조정: {name} = {circuit['config']['gpu_layers']}"
                    )

        except Exception as e:
            logger.error(f"❌ GPU 최적화 실패: {str(e)}")
            raise

    def _optimize_processing_speed(self) -> None:
        """처리 속도 최적화"""
        try:
            # 1. 배치 크기 최적화
            for circuit in self.llm_circuits.values():
                if self.resource_monitor["memory_usage"] > 80:
                    circuit["config"]["batch_size"] //= 2
                elif self.resource_monitor["memory_usage"] < 50:
                    circuit["config"]["batch_size"] *= 2

            # 2. 병렬 처리 최적화
            if self.resource_monitor["cpu_usage"] > 90:
                self.parallel_config["max_workers"] = max(
                    2, self.parallel_config["max_workers"] // 2
                )
            elif self.resource_monitor["cpu_usage"] < 60:
                self.parallel_config["max_workers"] = min(
                    os.cpu_count() * 2, self.parallel_config["max_workers"] * 2
                )

        except Exception as e:
            logger.error(f"❌ 처리 속도 최적화 실패: {str(e)}")
            raise

    def _optimize_cache_usage(self) -> None:
        """캐시 사용 최적화"""
        try:
            cache_system = self.info_circuit["cache_system"]

            # 1. 캐시 크기 최적화
            if (
                cache_system["current_size"]
                > cache_system["cleanup_threshold"] * cache_system["max_size"]
            ):
                self._cleanup_old_cache()

            # 2. 메모리-디스크 캐시 밸런싱
            self._balance_cache_distribution()

            # 3. 캐시 압축
            self._compress_cache_if_needed()

        except Exception as e:
            logger.error(f"❌ 캐시 최적화 실패: {str(e)}")
            raise

    def _monitor_system_health(self) -> None:
        """시스템 건강도 모니터링"""
        try:
            # 1. 기본 지표 수집
            metrics = {
                "memory": self.resource_monitor["memory_usage"],
                "gpu": self.resource_monitor["gpu_usage"],
                "cpu": self.resource_monitor["cpu_usage"],
                "disk": self.resource_monitor["disk_usage"],
                "resonance": self.system_state["resonance_level"],
                "consciousness": self.system_state["consciousness_level"],
            }

            # 2. 성능 지표 계산
            performance_score = self._calculate_performance_score(metrics)

            # 3. 건강도 평가
            health_status = self._evaluate_health_status(metrics, performance_score)

            # 4. 필요시 조치
            if health_status["needs_attention"]:
                self._take_health_action(health_status["issues"])

        except Exception as e:
            logger.error(f"❌ 건강도 모니터링 실패: {str(e)}")
            raise

    def _calculate_performance_score(self, metrics: Dict[str, float]) -> float:
        """성능 점수 계산"""
        try:
            # 1. 리소스 점수 (30%)
            resource_score = (
                (100 - metrics["memory"]) * 0.4
                + (100 - metrics["cpu"]) * 0.3
                + (100 - metrics["disk"]) * 0.3
            ) * 0.3

            # 2. 상태 점수 (40%)
            state_score = (
                metrics["resonance"] * 0.5 + metrics["consciousness"] * 0.5
            ) * 0.4

            # 3. GPU 점수 (30%)
            gpu_score = (1.0 - (metrics["gpu"] / self.memory_manager["max_vram"])) * 0.3

            return resource_score + state_score + gpu_score

        except Exception as e:
            logger.error(f"❌ 성능 점수 계산 실패: {str(e)}")
            return 0.0

    def _evaluate_health_status(
        self, metrics: Dict[str, float], performance_score: float
    ) -> Dict[str, Any]:
        """건강도 상태 평가"""
        try:
            issues = []

            # 1. 리소스 이슈 체크
            if metrics["memory"] > 90:
                issues.append("높은_메모리_사용량")
            if metrics["cpu"] > 95:
                issues.append("높은_CPU_사용량")
            if metrics["gpu"] > self.memory_manager["max_vram"] * 0.9:
                issues.append("높은_GPU_사용량")
            if metrics["disk"] > 95:
                issues.append("높은_디스크_사용량")

            # 2. 상태 이슈 체크
            if metrics["resonance"] < 0.9:
                issues.append("낮은_공진_수준")
            if metrics["consciousness"] < 0.9:
                issues.append("낮은_의식_수준")

            # 3. 성능 이슈 체크
            if performance_score < 0.7:
                issues.append("낮은_성능_점수")

            return {
                "needs_attention": len(issues) > 0,
                "issues": issues,
                "performance_score": performance_score,
            }

        except Exception as e:
            logger.error(f"❌ 건강도 평가 실패: {str(e)}")
            return {"needs_attention": True, "issues": ["평가_실패"]}

    def _take_health_action(self, issues: List[str]) -> None:
        """건강 이슈 조치"""
        try:
            for issue in issues:
                if issue == "높은_메모리_사용량":
                    self._optimize_memory_usage()
                elif issue == "높은_GPU_사용량":
                    self._optimize_gpu_usage()
                elif issue == "높은_CPU_사용량":
                    self._optimize_processing_speed()
                elif issue == "높은_디스크_사용량":
                    self._cleanup_resources()
                elif issue in ["낮은_공진_수준", "낮은_의식_수준"]:
                    self._synchronize_states()
                elif issue == "낮은_성능_점수":
                    self._optimize_performance()
                elif issue == "평가_실패":
                    self._self_diagnosis()

            logger.info(f"✅ 건강 이슈 조치 완료: {issues}")

        except Exception as e:
            logger.error(f"❌ 건강 이슈 조치 실패: {str(e)}")
            raise

    def _find_cooccurring_terms(
        self, terms: Dict[str, int]
    ) -> List[Tuple[str, str, float]]:
        """공기어 찾기"""
        try:
            pairs = []
            term_list = list(terms.keys())

            for i in range(len(term_list)):
                for j in range(i + 1, len(term_list)):
                    term1, term2 = term_list[i], term_list[j]
                    cooccurrence_score = self._calculate_cooccurrence_score(
                        term1, term2
                    )
                    if cooccurrence_score > 0.5:  # 임계값 이상인 경우만
                        pairs.append((term1, term2, cooccurrence_score))

            return sorted(pairs, key=lambda x: x[2], reverse=True)
        except Exception as e:
            logger.error(f"❌ 공기어 찾기 실패: {str(e)}")
            return []

    def _find_context_sequences(
        self, context_data: List[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """
        컨텍스트 데이터에서 순차 패턴(시간/상태/의미 흐름 등)을 LLM 자율 해석 + rule 기반으로 탐지
        """
        try:
            # 1. LLM 자율 해석 기반 순차 패턴 탐지
            meta_prompt = (
                "아래 컨텍스트 데이터에서 순차적(시간/상태/의미 흐름) 패턴을 모두 찾아 JSON 리스트로 반환하라.\n"
                f"{context_data}"
            )
            result = self.llm_circuits["self"]["model"](
                meta_prompt,
                max_tokens=512,
                stop=["\n\n", "###", "```"],
                temperature=0.5,
            )
            import json

            try:
                sequences = json.loads(result["choices"][0]["text"])
            except Exception:
                sequences = []
            # 2. rule 기반 보조(시간/타입 순서)
            for i in range(len(context_data) - 1):
                if self._is_sequential_context(context_data[i], context_data[i + 1]):
                    sequences.append(
                        {
                            "from": context_data[i],
                            "to": context_data[i + 1],
                            "type": "sequential",
                        }
                    )
            return sequences
        except Exception as e:
            logger.error(f"❌ _find_context_sequences 실패: {str(e)}")
            return []

    def _find_context_repetitions(
        self, context_data: List[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """
        컨텍스트 데이터에서 반복/유사 패턴을 LLM 자율 해석 + rule 기반으로 탐지
        """
        try:
            # 1. LLM 자율 해석 기반 반복/유사 패턴 탐지
            meta_prompt = (
                "아래 컨텍스트 데이터에서 반복되거나 유사한 패턴을 모두 찾아 JSON 리스트로 반환하라.\n"
                f"{context_data}"
            )
            result = self.llm_circuits["self"]["model"](
                meta_prompt,
                max_tokens=512,
                stop=["\n\n", "###", "```"],
                temperature=0.5,
            )
            import json

            try:
                repetitions = json.loads(result["choices"][0]["text"])
            except Exception:
                repetitions = []
            # 2. rule 기반 보조(유사성 체크)
            for i in range(len(context_data)):
                for j in range(i + 1, len(context_data)):
                    if self._is_similar_context(context_data[i], context_data[j]):
                        repetitions.append(
                            {
                                "original": context_data[i],
                                "repeated": context_data[j],
                                "type": "repetition",
                            }
                        )
            return repetitions
        except Exception as e:
            logger.error(f"❌ _find_context_repetitions 실패: {str(e)}")
            return []

    def _is_sequential_context(
        self, context1: Dict[str, Any], context2: Dict[str, Any]
    ) -> bool:
        """
        두 컨텍스트가 시간/상태/의미적으로 순차적으로 연결되는지 판단 (LLM 자율 해석 + rule)
        """
        try:
            # 1. 시간 순서 우선
            if "timestamp" in context1 and "timestamp" in context2:
                if context1["timestamp"] < context2["timestamp"]:
                    return True
            # 2. 타입/상태 흐름
            if "type" in context1 and "type" in context2:
                sequential_types = {
                    "error": ["warning", "info"],
                    "warning": ["info", "success"],
                    "info": ["success"],
                }
                if context2["type"] in sequential_types.get(context1["type"], []):
                    return True
            # 3. LLM 자율 해석 보조
            meta_prompt = f"아래 두 컨텍스트가 순차적으로 연결되는지(시간/상태/의미 흐름) 판단해 True/False로 답하라.\n{context1}\n{context2}"
            result = self.llm_circuits["self"]["model"](
                meta_prompt,
                max_tokens=8,
                stop=["\n", "###", "```"],
                temperature=0.0,
            )
            return "True" in result["choices"][0]["text"]
        except Exception as e:
            logger.error(f"❌ _is_sequential_context 실패: {str(e)}")
            return False

    def _is_similar_context(
        self, context1: Dict[str, Any], context2: Dict[str, Any]
    ) -> bool:
        """
        두 컨텍스트가 의미적으로 유사한지 판단 (LLM 자율 해석 + rule)
        """
        try:
            # 1. 타입 동일성
            if "type" in context1 and "type" in context2:
                if context1["type"] != context2["type"]:
                    return False
            # 2. 개념 유사성
            if "concepts" in context1 and "concepts" in context2:
                common = set(context1["concepts"]) & set(context2["concepts"])
                total = set(context1["concepts"]) | set(context2["concepts"])
                if total and len(common) / len(total) > 0.7:
                    return True
            # 3. LLM 자율 해석 보조
            meta_prompt = f"아래 두 컨텍스트가 의미적으로 유사한지 판단해 True/False로 답하라.\n{context1}\n{context2}"
            result = self.llm_circuits["self"]["model"](
                meta_prompt,
                max_tokens=8,
                stop=["\n", "###", "```"],
                temperature=0.0,
            )
            return "True" in result["choices"][0]["text"]
        except Exception as e:
            logger.error(f"❌ _is_similar_context 실패: {str(e)}")
            return False

    def _calculate_sequence_confidence(
        self, context1: Dict[str, Any], context2: Dict[str, Any]
    ) -> float:
        """순차 패턴 신뢰도 계산"""
        try:
            confidence = 0.5  # 기본 신뢰도

            # 시간 간격 기반 신뢰도 조정
            if "timestamp" in context1 and "timestamp" in context2:
                time_diff = (
                    context2["timestamp"] - context1["timestamp"]
                ).total_seconds()
                if time_diff < 60:  # 1분 이내
                    confidence += 0.3
                elif time_diff < 300:  # 5분 이내
                    confidence += 0.2
                elif time_diff < 3600:  # 1시간 이내
                    confidence += 0.1

            # 컨텍스트 유형 기반 신뢰도 조정
            if "type" in context1 and "type" in context2:
                if context1["type"] == "error" and context2["type"] == "warning":
                    confidence += 0.2
                elif context1["type"] == "warning" and context2["type"] == "info":
                    confidence += 0.2
                elif context1["type"] == "info" and context2["type"] == "success":
                    confidence += 0.2

            return min(1.0, confidence)
        except Exception as e:
            logger.error(f"❌ 순차 패턴 신뢰도 계산 실패: {str(e)}")
            return 0.5

    def _calculate_similarity_confidence(
        self, context1: Dict[str, Any], context2: Dict[str, Any]
    ) -> float:
        """유사성 신뢰도 계산"""
        try:
            confidence = 0.5  # 기본 신뢰도

            # 개념 유사성 기반 신뢰도 조정
            if "concepts" in context1 and "concepts" in context2:
                common_concepts = set(context1["concepts"]) & set(context2["concepts"])
                total_concepts = set(context1["concepts"]) | set(context2["concepts"])
                if total_concepts:
                    similarity = len(common_concepts) / len(total_concepts)
                    confidence += similarity * 0.5

            # 컨텍스트 유형 기반 신뢰도 조정
            if "type" in context1 and "type" in context2:
                if context1["type"] == context2["type"]:
                    confidence += 0.2

            return min(1.0, confidence)
        except Exception as e:
            logger.error(f"❌ 유사성 신뢰도 계산 실패: {str(e)}")
            return 0.5

    def _calculate_cooccurrence_score(self, term1: str, term2: str) -> float:
        """공기어 점수 계산"""
        try:
            # 두 용어가 함께 나타나는 라인 수 계산
            cooccurrence_count = 0
            total_lines = len(self.raw_memory_lines)

            for line in self.raw_memory_lines:
                if term1 in line and term2 in line:
                    cooccurrence_count += 1

            # 공기어 점수 계산 (PMI 유사)
            if total_lines > 0:
                return cooccurrence_count / total_lines
            return 0.0
        except Exception as e:
            logger.error(f"❌ 공기어 점수 계산 실패: {str(e)}")
            return 0.0

    def _parse_prompt(self, prompt: str) -> Dict[str, Any]:
        """
        자연어 프롬프트를 완전 자율적으로 해석하여 구조화된 의미/의도/명령/상태/맥락 반환
        (키워드 매핑/룰 기반 X, LLM 자율 해석)
        """
        try:
            # 1. 무의식-의식 동기화 context 준비
            context = {
                **self._get_current_context(),
                **self._get_unconscious_context(),
            }
            # 2. self 회로(노우히머스2) 자율 해석 프롬프트 구성
            meta_prompt = (
                "아래 프롬프트의 의미, 의도, 명령, 상태, 맥락을 최대한 구조적으로 분석해서 "
                "JSON/dict 형태로 반환하라. 키워드 매핑/룰기반 X, 완전 자율 해석:\n"
                f"{prompt}"
            )
            # 3. LLM 호출
            result = self.llm_circuits["self"]["model"](
                meta_prompt,
                max_tokens=512,
                stop=["\n\n", "###", "```"],
                temperature=0.7,
                context=context,
            )
            # 4. 결과 dict 파싱
            import json

            try:
                result_dict = json.loads(result["choices"][0]["text"])
            except Exception:
                result_dict = {"raw": result["choices"][0]["text"]}
            return result_dict
        except Exception as e:
            logger.error(f"❌ _parse_prompt 실패: {str(e)}")
            return {"error": str(e), "input": prompt}

    def _implement_basic_auth(self) -> dict:
        """실제 FastAPI 기반 기본 인증 라우터/핸들러 파일 생성 및 반환 (환경변수 기반 시크릿/경로 보안/오버라이드 방지)"""
        import os
        from pathlib import Path

        code = """
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from passlib.hash import bcrypt
import os

router = APIRouter()

class User(BaseModel):
    username: str
    password: str

users_db = {}

@router.post("/register")
def register(user: User):
    if user.username in users_db:
        raise HTTPException(status_code=400, detail="이미 존재하는 사용자입니다.")
    users_db[user.username] = bcrypt.hash(user.password)
    return {"msg": "회원가입 성공"}

@router.post("/login")
def login(user: User):
    if user.username not in users_db or not bcrypt.verify(user.password, users_db[user.username]):
        raise HTTPException(status_code=401, detail="인증 실패")
    return {"msg": "로그인 성공"}
"""
        path = os.path.join("ui", "api", "basic_auth.py")
        os.makedirs(os.path.dirname(path), exist_ok=True)
        # 오버라이드 방지
        if not Path(path).exists():
            with open(path, "w", encoding="utf-8") as f:
                f.write(code)
        return {"file": path, "desc": "FastAPI 기본 인증 라우터", "code": code}

    def _implement_advanced_security(self) -> dict:
        """실제 FastAPI 기반 JWT 인증/고급 보안 라우터 파일 생성 및 반환 (환경변수 기반 시크릿/경로 보안/오버라이드 방지)"""
        import os
        from pathlib import Path

        code = """
from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel
from passlib.hash import bcrypt
from jose import jwt, JWTError
from datetime import datetime, timedelta
import os

SECRET_KEY = os.environ.get("JWT_SECRET_KEY", "supersecretkey")
ALGORITHM = "HS256"

router = APIRouter()

class User(BaseModel):
    username: str
    password: str

users_db = {}

def create_access_token(data: dict, expires_delta: timedelta = timedelta(minutes=30)):
    to_encode = data.copy()
    expire = datetime.utcnow() + expires_delta
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

@router.post("/register")
def register(user: User):
    if user.username in users_db:
        raise HTTPException(status_code=400, detail="이미 존재하는 사용자입니다.")
    users_db[user.username] = bcrypt.hash(user.password)
    return {"msg": "회원가입 성공"}

@router.post("/login")
def login(user: User):
    if user.username not in users_db or not bcrypt.verify(user.password, users_db[user.username]):
        raise HTTPException(status_code=401, detail="인증 실패")
    token = create_access_token({"sub": user.username})
    return {"access_token": token, "token_type": "bearer"}

@router.get("/secure-data")
def secure_data(token: str):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if username not in users_db:
            raise HTTPException(status_code=401, detail="인증 실패")
        return {"data": f"{username}의 비밀 데이터"}
    except JWTError:
        raise HTTPException(status_code=401, detail="토큰 오류")
"""
        path = os.path.join("ui", "api", "advanced_security.py")
        os.makedirs(os.path.dirname(path), exist_ok=True)
        # 오버라이드 방지
        if not Path(path).exists():
            with open(path, "w", encoding="utf-8") as f:
                f.write(code)
        return {"file": path, "desc": "FastAPI JWT 고급 보안 라우터", "code": code}

    def _implement_semantic_colors(self) -> dict:
        """실제 semantic color palette 파일 생성 및 반환"""
        colors = {
            "success": "#10b981",
            "error": "#ef4444",
            "warning": "#f59e42",
            "info": "#3b82f6",
            "primary": "#6366f1",
            "secondary": "#64748b",
            "background": "#f9fafb",
            "surface": "#ffffff",
            "onPrimary": "#fff",
            "onSecondary": "#fff",
            "onBackground": "#222",
            "onSurface": "#222",
        }
        path = os.path.join("ui", "src", "styles", "semantic-colors.json")
        os.makedirs(os.path.dirname(path), exist_ok=True)
        import json

        with open(path, "w", encoding="utf-8") as f:
            json.dump(colors, f, ensure_ascii=False, indent=2)
        return {"file": path, "desc": "semantic color palette", "colors": colors}

    def _implement_dark_mode_colors(self) -> dict:
        """다크모드 색상 팔레트 파일 생성 및 반환"""
        colors = {
            "background": "#18181b",
            "surface": "#23272f",
            "primary": "#6366f1",
            "secondary": "#64748b",
            "onPrimary": "#fff",
            "onSecondary": "#fff",
            "onBackground": "#fff",
            "onSurface": "#fff",
        }
        path = os.path.join("ui", "src", "styles", "dark-colors.json")
        os.makedirs(os.path.dirname(path), exist_ok=True)
        import json

        with open(path, "w", encoding="utf-8") as f:
            json.dump(colors, f, ensure_ascii=False, indent=2)
        return {"file": path, "desc": "dark mode color palette", "colors": colors}

    def _implement_font_system(self) -> dict:
        """폰트 시스템 예시 파일 생성 및 반환"""
        fonts = {
            "heading": "Pretendard, sans-serif",
            "body": "Pretendard, sans-serif",
            "mono": "Fira Mono, monospace",
        }
        path = os.path.join("ui", "src", "styles", "fonts.json")
        os.makedirs(os.path.dirname(path), exist_ok=True)
        import json

        with open(path, "w", encoding="utf-8") as f:
            json.dump(fonts, f, ensure_ascii=False, indent=2)
        return {"file": path, "desc": "font system", "fonts": fonts}

    def _implement_type_scale(self) -> dict:
        """타입 스케일 예시 파일 생성 및 반환"""
        scale = {
            "h1": "2.25rem",
            "h2": "1.5rem",
            "h3": "1.25rem",
            "body": "1rem",
            "caption": "0.875rem",
        }
        path = os.path.join("ui", "src", "styles", "type-scale.json")
        os.makedirs(os.path.dirname(path), exist_ok=True)
        import json

        with open(path, "w", encoding="utf-8") as f:
            json.dump(scale, f, ensure_ascii=False, indent=2)
        return {"file": path, "desc": "type scale", "scale": scale}

    def _implement_text_styles(self) -> dict:
        """텍스트 스타일 예시 파일 생성 및 반환"""
        styles = {
            "heading": {"fontWeight": 700, "lineHeight": 1.2},
            "body": {"fontWeight": 400, "lineHeight": 1.5},
            "caption": {"fontWeight": 400, "lineHeight": 1.4},
        }
        path = os.path.join("ui", "src", "styles", "text-styles.json")
        os.makedirs(os.path.dirname(path), exist_ok=True)
        import json

        with open(path, "w", encoding="utf-8") as f:
            json.dump(styles, f, ensure_ascii=False, indent=2)
        return {"file": path, "desc": "text styles", "styles": styles}

    def _implement_spacing_scale(self) -> dict:
        """스페이싱 스케일 예시 파일 생성 및 반환"""
        scale = [0, 4, 8, 12, 16, 20, 24, 32, 40, 48, 56, 64]
        path = os.path.join("ui", "src", "styles", "spacing-scale.json")
        os.makedirs(os.path.dirname(path), exist_ok=True)
        import json

        with open(path, "w", encoding="utf-8") as f:
            json.dump(scale, f, ensure_ascii=False, indent=2)
        return {"file": path, "desc": "spacing scale", "scale": scale}

    def _implement_layout_spacing(self) -> dict:
        """레이아웃 스페이싱 예시 파일 생성 및 반환"""
        layout = {"container": 24, "section": 32, "card": 16}
        path = os.path.join("ui", "src", "styles", "layout-spacing.json")
        os.makedirs(os.path.dirname(path), exist_ok=True)
        import json

        with open(path, "w", encoding="utf-8") as f:
            json.dump(layout, f, ensure_ascii=False, indent=2)
        return {"file": path, "desc": "layout spacing", "layout": layout}

    def _implement_component_spacing(self) -> dict:
        """컴포넌트 스페이싱 예시 파일 생성 및 반환"""
        comp = {"button": 12, "input": 8, "card": 16}
        path = os.path.join("ui", "src", "styles", "component-spacing.json")
        os.makedirs(os.path.dirname(path), exist_ok=True)
        import json

        with open(path, "w", encoding="utf-8") as f:
            json.dump(comp, f, ensure_ascii=False, indent=2)
        return {"file": path, "desc": "component spacing", "component": comp}

    def _implement_button_system(self) -> dict:
        """버튼 컴포넌트 예시 파일 생성 및 반환"""
        code = """import React from "react"\nimport "./Button.css"\n\nexport default function Button({ children, ...props }) {\n  return <button className="btn" {...props}>{children}</button>\n}\n"""
        css = ".btn { padding: 8px 16px; border-radius: 6px; background: #6366f1; color: #fff; border: none; font-weight: 600; cursor: pointer; }"
        comp_path = os.path.join("ui", "src", "components", "Button.jsx")
        css_path = os.path.join("ui", "src", "components", "Button.css")
        os.makedirs(os.path.dirname(comp_path), exist_ok=True)
        with open(comp_path, "w", encoding="utf-8") as f:
            f.write(code)
        with open(css_path, "w", encoding="utf-8") as f:
            f.write(css)
        return {
            "file": comp_path,
            "css": css_path,
            "desc": "React Button 컴포넌트",
            "code": code,
        }

    def _implement_input_system(self) -> dict:
        """인풋 컴포넌트 예시 파일 생성 및 반환"""
        code = """import React from "react"\nimport "./Input.css"\n\nexport default function Input(props) {\n  return <input className="input" {...props} />\n}\n"""
        css = ".input { padding: 8px 12px; border-radius: 4px; border: 1px solid #d1d5db; font-size: 1rem; }"
        comp_path = os.path.join("ui", "src", "components", "Input.jsx")
        css_path = os.path.join("ui", "src", "components", "Input.css")
        os.makedirs(os.path.dirname(comp_path), exist_ok=True)
        with open(comp_path, "w", encoding="utf-8") as f:
            f.write(code)
        with open(css_path, "w", encoding="utf-8") as f:
            f.write(css)
        return {
            "file": comp_path,
            "css": css_path,
            "desc": "React Input 컴포넌트",
            "code": code,
        }

    def _implement_icon_system(self) -> dict:
        """아이콘 시스템 예시 파일 생성 및 반환"""
        code = """import React from "react"\n\nexport function CheckIcon(props) {\n  return <svg width={20} height={20} fill="none" stroke="#10b981" strokeWidth={2} viewBox="0 0 20 20" {...props}><path d="M5 10l4 4 6-8" /></svg>\n}\n"""
        comp_path = os.path.join("ui", "src", "components", "Icon.jsx")
        os.makedirs(os.path.dirname(comp_path), exist_ok=True)
        with open(comp_path, "w", encoding="utf-8") as f:
            f.write(code)
        return {"file": comp_path, "desc": "React Icon 컴포넌트", "code": code}

    def _implement_badge_system(self) -> dict:
        """뱃지 컴포넌트 예시 파일 생성 및 반환"""
        code = """import React from "react"\nimport "./Badge.css"\n\nexport default function Badge({ children, type = "info" }) {\n  return <span className={`badge badge-${type}`}>{children}</span>\n}\n"""
        css = ".badge { padding: 2px 8px; border-radius: 8px; font-size: 0.85rem; } .badge-info { background: #3b82f6; color: #fff; } .badge-success { background: #10b981; color: #fff; } .badge-error { background: #ef4444; color: #fff; }"
        comp_path = os.path.join("ui", "src", "components", "Badge.jsx")
        css_path = os.path.join("ui", "src", "components", "Badge.css")
        os.makedirs(os.path.dirname(comp_path), exist_ok=True)
        with open(comp_path, "w", encoding="utf-8") as f:
            f.write(code)
        with open(css_path, "w", encoding="utf-8") as f:
            f.write(css)
        return {
            "file": comp_path,
            "css": css_path,
            "desc": "React Badge 컴포넌트",
            "code": code,
        }

    def _implement_form_components(self) -> dict:
        """폼 컴포넌트 예시 파일 생성 및 반환"""
        code = """import React from "react"\nimport Input from "./Input"\nimport Button from "./Button"\n\nexport default function SimpleForm({ onSubmit }) {\n  const handleSubmit = e => {\n    e.preventDefault();\n    const data = new FormData(e.target);\n    onSubmit(Object.fromEntries(data.entries()));\n  }\n  return (\n    <form onSubmit={handleSubmit}>\n      <Input name="username" placeholder="아이디" />\n      <Input name="password" type="password" placeholder="비밀번호" />\n      <Button>로그인</Button>\n    </form>\n  )\n}\n"""
        comp_path = os.path.join("ui", "src", "components", "SimpleForm.jsx")
        os.makedirs(os.path.dirname(comp_path), exist_ok=True)
        with open(comp_path, "w", encoding="utf-8") as f:
            f.write(code)
        return {"file": comp_path, "desc": "React Form 컴포넌트", "code": code}

    def _implement_card_system(self) -> dict:
        """카드 컴포넌트 예시 파일 생성 및 반환"""
        code = """import React from "react"\nimport "./Card.css"\n\nexport default function Card({ title, children }) {\n  return (\n    <div className="card">\n      <h3>{title}</h3>\n      <div>{children}</div>\n    </div>\n  )\n}\n"""
        css = ".card { border: 1px solid #e5e7eb; border-radius: 8px; padding: 16px; background: #fff; box-shadow: 0 2px 8px #0001; }"
        comp_path = os.path.join("ui", "src", "components", "Card.jsx")
        css_path = os.path.join("ui", "src", "components", "Card.css")
        os.makedirs(os.path.dirname(comp_path), exist_ok=True)
        with open(comp_path, "w", encoding="utf-8") as f:
            f.write(code)
        with open(css_path, "w", encoding="utf-8") as f:
            f.write(css)
        return {
            "file": comp_path,
            "css": css_path,
            "desc": "React Card 컴포넌트",
            "code": code,
        }

    def _implement_list_components(self) -> dict:
        """리스트 컴포넌트 예시 파일 생성 및 반환"""
        code = """import React from "react"\n\nexport default function List({ items }) {\n  return (\n    <ul>\n      {items.map((item, i) => <li key={i}>{item}</li>)}\n    </ul>\n  )\n}\n"""
        comp_path = os.path.join("ui", "src", "components", "List.jsx")
        os.makedirs(os.path.dirname(comp_path), exist_ok=True)
        with open(comp_path, "w", encoding="utf-8") as f:
            f.write(code)
        return {"file": comp_path, "desc": "React List 컴포넌트", "code": code}

    def _implement_navigation_components(self) -> dict:
        """네비게이션 컴포넌트 예시 파일 생성 및 반환"""
        code = """import React from "react"\n\nexport default function Navbar({ links }) {\n  return (\n    <nav>\n      <ul style={{ display: "flex", gap: 16 }}>
        {links.map((l, i) => <li key={i}><a href={l.href}>{l.label}</a></li>)}\n      </ul>\n    </nav>\n  )\n}\n"""
        comp_path = os.path.join("ui", "src", "components", "Navbar.jsx")
        os.makedirs(os.path.dirname(comp_path), exist_ok=True)
        with open(comp_path, "w", encoding="utf-8") as f:
            f.write(code)
        return {"file": comp_path, "desc": "React Navbar 컴포넌트", "code": code}

    def _implement_header_system(self) -> dict:
        """헤더 컴포넌트 예시 파일 생성 및 반환"""
        code = """import React from "react"\n\nexport default function Header({ title }) {\n  return <header style={{ padding: 16, background: "#6366f1", color: "#fff" }}><h1>{title}</h1></header>\n}\n"""
        comp_path = os.path.join("ui", "src", "components", "Header.jsx")
        os.makedirs(os.path.dirname(comp_path), exist_ok=True)
        with open(comp_path, "w", encoding="utf-8") as f:
            f.write(code)
        return {"file": comp_path, "desc": "React Header 컴포넌트", "code": code}

    def _implement_footer_system(self) -> dict:
        """푸터 컴포넌트 예시 파일 생성 및 반환"""
        code = """import React from "react"\n\nexport default function Footer() {\n  return <footer style={{ padding: 16, background: "#23272f", color: "#fff", textAlign: "center" }}>© 2024 EchoBrain</footer>\n}\n"""
        comp_path = os.path.join("ui", "src", "components", "Footer.jsx")
        os.makedirs(os.path.dirname(comp_path), exist_ok=True)
        with open(comp_path, "w", encoding="utf-8") as f:
            f.write(code)
        return {"file": comp_path, "desc": "React Footer 컴포넌트", "code": code}

    def _implement_sidebar_system(self) -> dict:
        """사이드바 컴포넌트 예시 파일 생성 및 반환"""
        code = """import React from "react"\n\nexport default function Sidebar({ children }) {\n  return <aside style={{ width: 220, background: "#f3f4f6", padding: 16 }}>{children}</aside>\n}\n"""
        comp_path = os.path.join("ui", "src", "components", "Sidebar.jsx")
        os.makedirs(os.path.dirname(comp_path), exist_ok=True)
        with open(comp_path, "w", encoding="utf-8") as f:
            f.write(code)
        return {"file": comp_path, "desc": "React Sidebar 컴포넌트", "code": code}

    def _implement_modal_system(self) -> dict:
        """모달 컴포넌트 예시 파일 생성 및 반환"""
        code = """import React, { useState } from "react"\n\nexport default function Modal({ open, onClose, children }) {\n  if (!open) return null;\n  return (\n    <div style={{ position: "fixed", top: 0, left: 0, width: "100vw", height: "100vh", background: "#0008", display: "flex", alignItems: "center", justifyContent: "center" }}>\n      <div style={{ background: "#fff", padding: 32, borderRadius: 12, minWidth: 320 }}>\n        <button onClick={onClose} style={{ float: "right" }}>닫기</button>\n        {children}\n      </div>\n    </div>\n  )\n}\n"""
        comp_path = os.path.join("ui", "src", "components", "Modal.jsx")
        os.makedirs(os.path.dirname(comp_path), exist_ok=True)
        with open(comp_path, "w", encoding="utf-8") as f:
            f.write(code)
        return {"file": comp_path, "desc": "React Modal 컴포넌트", "code": code}

    @staticmethod
    def load_txt_lines(filepath, encoding="utf-8"):
        """
        텍스트 파일을 한 줄씩 읽어서 리스트로 반환하는 유틸 함수
        """
        with open(filepath, "r", encoding=encoding) as f:
            return [line.strip() for line in f.readlines()]


